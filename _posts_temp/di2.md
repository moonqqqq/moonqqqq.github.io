---
title: Nest.js 모듈 구조 관리 (Avoiding circular dependency)
description: 전체 코드 구조를 깔끔히하기.
header: Nest.js 모듈 구조 관리 (Avoiding circular dependency)
tags:
 - nest.js
 - circular dependency
 - module
---

어떤 아키텍쳐를 쓰던 DI(dependency injection)는 대부분 이용된다. Nest.js의 기본 구조도 그렇다.
그런데 DI로 개발하다보면 의존성이 꼬이는 일이 발생하는 경우가 있다. 바쁘다는 이유로 대충 생각해서 일하다보면 그럴때도 있고, 새로운 기능에 대해 개발도중에 기존 의존 구조와 상호의존되는 상황도 발생한다. 엄청 복잡하게 의존성이 엉켜서 전체 구조 파악이 힘들 때도 있겠지만, 그 정도가 되기전에 보통 **circular dependency**가 발생한다. 
이 때 *lazy loading*을 이용해서 circular dependency 발생 없이 개발할수도 있지만 상호의존은 최악의 구조이기 때문에 최대한 불가피한 경우에만 써야한다.

내가 관리하는 프로젝트들에서 상호 의존을 피하기 위한 규칙들은 아래와 같다.

## 1. 테이블 마다 모듈을 만든다는 생각부터 버려야한다.
나 또한 개발 초기에는 대부분의 백엔드 강의가 CRUD 강의였기때문에 테이블과 거의 1대1 매칭이 됐다. 그렇게 배웠다보니 나도 초기에는 실무에서 그렇게 해왔다. 하지만 어느 순간 상호 의존하는 상황이 발생한다.(지금도 꽤 발생한다..) 가장 큰 이유는 개별 모듈이 너무 커졌기 때문이다.

## 종류에 따라
![1](/img/writing-images/user-module.png)
User, Order, Product 이 3가지의 테이블을 가진 서비스를 생각해보자. 모듈을 테이블대로 3개만 만들어서 이용한다면 초기에는 기능이 괜찮았겠지만 서비스가 커질수록 기능이 아주 많아지면서 개별 모듈의 기능들이 많아진다(책임이 커진다).
예를 들면, User의 종류도 처음엔 한 종류일 수 있었다. 그런데 한달뒤에 비로그인 유저가 주문할수 있는 기능도 생겨날수 있다. 혹은 유저 등급에 따라 기능이 분리될수도 있게 된다.(e.g. PaidUser, UnpaidUser).

> "기능이 많다" 라는 건 다른 모듈의 기능을 필요할(의존할) 확률이 높아진다와 같은 말이다.

PaidUser, UnpaiedUser, NonLoginedUser 처럼 여러개로 나눠 모듈을 관리한다면 PaidUser에서만 결제 정보에 대해 의존하면 된다. UnpaiedUser와 NonLoginedUser 모듈에서는 결제 정보를 의존하지 않아도 된다. 반대로 UnpaidUser에서만 필요한 모듈은 Unpaied모듈에서만 의존하고 다른 곳에서는 의존하지 않는다. **정확히 말하면 정말 필요한 기능만 필요한 곳에서 의존하는 구조가 성립된다.** 

이렇게 구분하면 구조가 명확해진다. 하지만 한 뿌리에서 나온 모듈들이다보니 공통되는 기능들이 꽤나 존재하게 된다. 그럴 때는 User 모듈을 공통 기능/API 모듈로 사용한다. 혹은 좀 더 명시적이고 싶다면 UserCore, UserShare 모듈로 이름 지어도 좋다.

## 혼합된 형식으로
![1](/img/writing-images/order-and-user-module.png)
한뿌리에서 나온 여러 종류에 따라 분리되는 모듈이 절반을 차지한다면 나머지 절반은 혼합된 형식이 차지한다. UserOrder, NonUserOrder 모듈처럼 나뉠수 있다. 쇼핑몰에서 흔히 볼수 있는 비회원 구매 기능을 생각하면 좋다. 두가지 데이터를 혼합한 모듈을 만들면 모듈의 기능이 분리된다. 나누지 않았다면 Order 모듈에서 모두 책임을 져야하니 말이다. 위 그림을 보면 NonLoginedUserOrder와 UserOrder는 OrderCore와 UserCore를 의존한다.


# 2. 방향 또한 중요하다.
User, Order에서 둘의 관계는 User가 Order를 여러개 가진다. 일대다(완벽히 일대다는아니지만)와 같은 관계에서는 '다'가 '일'을 의존하도록 해야한다. 논리적으로 대부분이 그렇다. Order API를 개발할 때 User 정보를 가져올 확률이 높지 User API에서 Order 정보를 가져올 일은 그리 많지않다. 있을수 있지만 비율적으로 비교가 불가하다. 그러니 '다' 방향에서 '일'을 의존해야한다. '일'에서 '다'를 의존하게 된다면 기존 구조가 불량할 확률이 높다.

한가지로 규칙을 정해야하는 상황이니 '다'에서 '일'을 의존하는 방향을 규칙으로 한다.

# 3. 잔가지 모듈은 최대한 의존하지 않는게 깔끔하다.
위에서 NonLoginedUserOrder, UserOrder 모듈이 OrderCore 모듈이라는 뿌리에서 나온 모듈들이다. 그리고 NonLoginedUser, PaidUser, NonPaidUser 모듈들 또한 UserCore모듈에서 나온 모듈들이다. 이 모듈들이 다른 모듈들에 의존성으로 주입된다면 의존성 구조가 꽤나 복잡해질수 있다. (그런데 잔가지 모듈을 의존해도 Circular dependency는 잘발생하지않긴한다.) 최대한 깔끔하게 구성을 하는 것이 목적이니 지양하도록한다.
//////////


2. 테이블 마다 모듈을 만드는게 아니라면?
그런데 테이블마다 모듈이 생기긴한다. 하지만 모든 테이블의 100퍼센트가 아니라 70~80퍼센트가 모듈로 생긴다. 나머지 20~30은 다른 모듈안에 내장된다. 
당연한거지만 이유는 데이터들 또한 구조화돼있기때문이다. User, Profile이 각자 모듈로 있을수도 있지만 User 모듈안에서 Profile 기능이 있으면 되는 것처럼말이다. 
(Profile 기능이 많다면 따로 빼는게 좋긴하다.)

테이블과 매칭돼서 생긴 모듈들은 필수적인 것들이라 당연하다. 여기서 추가적으로 생기는 모듈들이 있다. 이들이 좋은 구조에 핵심적인 역할을 한다.

서비스 기능에 User와 Order가 있다면 "UserOrder", "NonUserOrder"가 생길수 있다.
당연한 것들이라 그리고 여기서 제일 중요한점은  제외한 다른 모듈들이다.



/////

0 - 테이블 별로 모듈을 만들면 안된다. 거의 테이블마다 모듈이 생기긴하는데 개수가 1:1로 매칭된다는 의미가 아니라 보통 테이블보다 모듈 개수가 훨씬 많아진다.
NonUserOrder, CustomerOrder, Order(or OrderCore)

0 - Customer모듈, Order모듈 이 두가지의 모듈로 두 관련 데이터를 모두 책임지지않는다. 

0 - 모듈간에도 공통된 기능이 많이 존재한다. 보통 같은 부모 카테고리에서 뻗어나온 하위카테고리들이 그렇다.

- order, receipt 관계 "GET order/:id/receipt"  or "GET receipt?orderId=123"
    - 재사용성: B와 관련된 로직이 A 모듈 내에만 있으므로, 다른 모듈에서 재사용하기 어려울 수 있습니다.
    - 
    장점:

	•	명확한 계층 구조: Order와 관련된 Receipt는 Order의 하위 자원으로 명확하게 표현됩니다.
	•	자연스러운 URL: Order와 관련된 자원을 계층적으로 접근할 수 있어 URL이 직관적입니다.
	•	API 명세 간결: 하나의 Order 컨트롤러 내에서 관리할 수 있어 관리가 편리합니다.

단점:

	•	단일 책임 원칙 위배 가능성: Order 모듈이 너무 많은 책임을 가지게 되어 복잡해질 수 있습니다.
	•	확장성 제한: Receipt가 Order 외 다른 자원과도 연관될 가능성이 있을 때 유연하지 않습니다.

2. GET receipt?orderId=123

장점:

	•	모듈화: Receipt를 독립된 모듈로 관리함으로써 단일 책임 원칙을 따를 수 있습니다.
	•	유연성: Receipt 모듈이 독립적이므로 다른 자원과 연관될 때도 쉽게 확장할 수 있습니다.
	•	재사용성: Receipt 관련 로직을 다른 곳에서도 재사용하기 쉽습니다.

단점:

	•	URL의 직관성 저하: URL에서 계층 구조가 명확하지 않아 직관성이 떨어질 수 있습니다.
	•	관리 복잡도 증가: 여러 모듈을 관리해야 하므로 초기 설정과 관리가 다소 복잡할 수 있습니다.
기능적 확장성과 모듈화 측면에서 고려할 때, Receipt 모듈을 별도로 만드는 것을 추천드립니다. 이는 장기적으로 유지보수와 확장성에서 더 큰 이점을 가져올 것입니다. Receipt 모듈을 별도로 두면, 새로운 요구사항이나 기능이 추가될 때 더 유연하게 대처할 수 있습니다.


- share 모듈은 모든 모듈이 의존할수 있다.

- lazy loading이라는 방법도 있다만.

