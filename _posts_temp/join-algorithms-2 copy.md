---
title: Join 알고리즘 대표적 3가지 특징/최적화
description: RDB join 알고리즘 3가지 최적화
header: Join 알고리즘 특징/최적화
tags:
 - database
 - join
---

#### 시리즈 목차
[1. Join 알고리즘의 종류](https://moonqqqq.github.io/join-algorithms-1) <br>
<U>(현재글) 2. Join 알고리즘 최적화</U> <br>

```
Join 알고리즘의 특징을 알아보기전에 먼저 액세스 방식부터 확인하고 가자.
```

## 랜덤 액세스 vs 순차 액세스
조인 종류를 보기전에 먼저 랜덤 액세스, 순차 액세스가 뭔지 알아야한다.

## 랜덤 액세스
랜덤 액세스는 특정 행을 하나 찝어서 찾는 것이다. 
"랜덤" 이라는 단어가 붙어서 이름과 내용이 잘매칭되지않는다. 데이터가 저장된 순서에 상관없이 접근한다고 해서 "랜덤"이 붙었다고 한다. (난 아직도 이름을 잘못지었다고 생각한다..) 그리고 메모리의 임의 위치에 저장된 데이터를 접근할 수 있음을 의미한다고 여러곳에서 설명한다.
데이터베이스는 특정 행을 찾는 과정에서 "tree-search"가 실행되는데 "tree-search"를 랜덤 액세스라고 생각하면 된다. 이 과정이 여러번 진행되면 순차 액세스에 비해 훨씬 시간이 많이 든다. 예를 들어 <U>(캐시, 페이지 프리페칭이 없다고 가정하자.)</U> ID가 1,2,3 인 데이터를 가져와야할 때 랜덤액세스를 이용하게 되면 1,2,3 ID에 대한 랜덤엑세스가 3번 진행된다. (tree-search가 3번 진행된다.)

## 순차 액세스
반면에 순차 액세스는 디비가 데이터를 검색할 때 특정 행을 가져오는것이 아니라 한 뭉치의 데이터들을 가져오는 것을 활용한다. 디비에서 데이터는 페이지로 관리되고 페이지에는 순서대로 여러개의 데이터가 저장되어있다. ID가 1,2,3인 데이터가 같은 페이지에 저장돼있고, ID가 4,5,6인 데이터들이 같은 페이지에 저장돼있다고 보면 된다. 그렇기 때문에 ID === 1 인 데이터를 가져온다면 이미 2,3 데이터도 가져온것이기 때문에 ID === 1 데이터를 읽은 후 바로 **추가적인 tree-search없이** ID === 2 인 데이터에 접근할수 있다.


# 3가지 조인 비교

3가지 조인 알고리즘이 어떤 상황에 선택되는지 알아보자.
일단은 시간복잡도부터 따져보면. Nested Loop은 O(N*M), Hash와 Sort-Merge는 O(N+M)이다.

조인 알고리즘은 **WHERE문으로 필터링된 데이터의 갯수**에 따라 갈린다.
WHERE문으로 필터링이 많이돼서 Join할 데이터가 적다면 Nested Loop 조인을 이용한다. WHERE문으로 필터링되는 양이 적다면 Hash 조인과 Merge 조인을 이용한다.

## Nested loop

Nested Loop Join은 보통 WHERE문으로 필터링된 데이터가 적을 때 이용된다. 이유는 단순하다. **Nested Loop은 특별한 초기 프로세스가 없기 때문이다.** Hash 조인은 **Hash 테이블을 만들어야하고**, Merge 조인은 조인하는 테이블들을 Join 키를 기준으로 **정렬해야한다.** Nested Loop은 아무것도 없다. 그냥 하나하나 비교하는게 끝이다.
시간복잡도가 다른 알고리즘보다 높음에도 불구하고(O(N*M)) 다른 알고리즘과 다르게 초기 작업이 없기때문에 가볍게 진행될수 있다.
다만 데이터가 많아지만 시간복잡도의 성능 저하가 기초작업에 필요한 성능 저하보다 커지게된다. 그렇게 되면 다른 조인 알고리즘을 선택하게 된다.

## Hash vs Sort Merge
이제 Hash 조인과 Merge 조인 중 어떤 알고리즘이 선택되는지에 대해 알아보자.

### 인덱스

### 이용가능한 메모리

### 데이터 분포

### 양쪽 테이블의 데이터 양



### 첫번째는 **"인덱스"**의 여부로 갈린다. 

### 양쪽 Join 필드에 인덱스가 있다면
Join하는 필드에 인덱스가 설정돼있다면 Sort Merge Join이 유리하다.

Sort Merge Join은 이름부터 정렬이 붙어있는것만봐도 알수 있듯이 양쪽테이블을 정렬하는 것이 시작이다. 그런데 **정렬을 진행할 조인키에 이미 인덱스가 설정되어있다면 이미 정렬이 돼있는 것이기때문에 정렬 과정이 생략된다.** 정렬 작업이 제일 큰 리소스를 소모하는 단계였기때문에 Hash Join보다 큰 성능을 낼수 있다.
둘다 O(N+M)의 시간복잡도를 가졌는데 Sort Merge Join은 기초작업(정렬)이 사라진 반면 Hash Join은 여전히 기초 작업(해시 테이블을 만드는 작업)이 필요하다. 그러므로 성능상 우위에 있다.

### 양쪽 Join 필드에 인덱스가 있지않다면.
반면에 Join 필드에 인덱스가 설정돼있지않다면 Hash Join이 유리할수 있다.
애초에 Hash 조인은 해시함수를 실행한 값으로 조인을 판별하기 때문에 어떠한 정렬도 필요없다. 해시테이블 자체가 key로 value에 접근하기때문에 정렬될 필요가 없다. 정렬에 드는 시간이 해시 테이블을 만드는 시간보다 크다면 


# Nested Loop Join

## 한계
1. 인덱스를 기반한 랜덤 액세스가 쓰이기 때문에 조인으로 검색되는 데이터가 많아지면 느리다.
2. 인덱스 기반이니 적당한 인덱스 설정이 기반되어야한다.
3. where로 최대한 데이터 갯수를 초장부터 줄여야 성능이 나온다.


# Sort Merge Join

Join에 이용되는 필드가 인덱스로 정렬돼있다면 정렬을 할 필요가 없어진다. 이 알고리즘 이름 자체에 sort가 들어있는데 sort를 안해도 된다면 성능이 아주 많이 향상된다.

Join 키가 복잡하면 비교하기 힘드니 좋지 않다
이러한 조인 키를 직접 비교하는 것은 많은 CPU 자원을 소모하게 됩니다.

데이터의 분포도. 해시의 특성상 다른 인풋임에도 같은 아웃풋이 나올 때가 있다.그렇게 되면 헤시테이블의 동일한 키가 여러개의 값을 가지게 된다. 그렇게 되면 해시함수로 검색한 결과값으로 조인 데이터를 바로 찾지 못하고 해시테이블의 매칭 값들중 한번더 비교를 해야한다.

기본적으로 Join은 데이터가 한번은 필터링 된 이후에 실행된다. WHERE 조건을 안걸고 모든 데이터를 가져오는 쿼리는 거의 없기때문이다. 기본적인 기능일수록 조건이 명확해서 WHERE문의 결과가 적기때문에 Join을 실행해야할 데이터 자체가 적다. 그러나 기능이 고도화되다보면 쿼리 자체가 복잡해진다. (대표적으로 서브쿼리) 그러다보면 WHERE 조건의 결과 데이터가 커진다.

이 흐름에 따라 Join 알고리즘이 어떻게 선택되는지 알아보자.

간단한 쿼리에서는 where조건으로 범위를 쉽게 좁히기때문에 쿼리 결과 데이터의 수가 적다. 그럴 때는 Nested Loop Join으로 데이터를 병합한다.

데이터베이스 검색은 기본적으로 WHERE문으로 꽤나 많은 데이터가 걸러진후 적은 양의 데이터



# Join 알고리즘이 어떻게 선택되는지 알아보자.
3가지 Join을 모른다면 1편을 읽고 오거나 다른 곳에서 공부하고 오시길.

## Nested Loop Join
3가지중 가장 특별하지 않다. 이름 그대로 단순히 중첩 루프(for문)를 돌며 조건에 맞는 조인키를 찾는다. 단순히 O(N*M) 시간복잡도를 가질뿐 다른 특별한 점은 없다. 
O(N*M)이다보니 다른 Join 알고리즘보다 느리다.

## Hash Join
Hash 테이블을 만들다보니 해시 테이블을 만드는 비용이 든다. 그래서 작은 데이터

----

3가지 조인 쿼리가 어떤 상황에 좋은지 알아보자.
일단은 시간복잡도부터. Nested Loop은 O(N*M), Hash와 Merge는 O(N+M)이다.

조인 알고리즘은 WHERE문으로 필터링된 데이터의 갯수에 따라 갈린다.
WHERE문으로 필터링이 많이돼서 Join할 데이터가 적다면 Nested Loop 조인을 이용한다. WHERE문으로 필터링되는 양이 적다면 Hash 조인과 Merge 조인을 이용한다. 

## Nested loop

Nested Loop Join은 보통 WHERE문으로 필터링된 데이터가 적을 때 이용된다. 이유는 단순하다. **Nested Loop은 특별한 초기 프로세스가 없기 때문이다.** Hash 조인은 **Hash 테이블을 만들어야하고**, Merge 조인은 조인하는 테이블들을 Join 키를 기준으로 **정렬해야한다.** Nested Loop은 아무것도 없다. 그냥 하나하나 비교하는게 끝이다.
시간복잡도가 다른 알고리즘보다 높음에도 불구하고(O(N*M)) 다른 알고리즘과 다르게 초기 작업이 없기때문에 가볍게 진행될수 있다.
다만 데이터가 많아지만 시간복잡도의 성능 저하가 기초작업에 필요한 성능 저하보다 커지게된다. 그렇게 되면 다른 조인 알고리즘을 선택하게 된다.

## Hash vs Sort Merge
이제 Hash 조인과 Merge 조인 중 어떤 알고리즘이 선택되는지에 대해 알아보자. 

### 첫번째는 **"인덱스"**의 여부로 갈린다. 
Join하는 필드에 인덱스가 설정돼있다면 Sort Merge Join을 선택한다.

Sort Merge Join은 이름부터 정렬이 붙어있는것만봐도 알수 있듯이 양쪽테이블을 Join할때 정렬부터 진행한다. 그런데 **정렬을 진행할 조인키에 이미 인덱스가 설정되어있다면 이미 정렬이 돼있는 것이기때문에 정렬 과정이 생략된다.** 정렬 작업이 제일 큰 리소스를 소모하는 단계였기때문에 Hash Join보다 큰 성능을 낼수 있다.

반면에 Join 필드에 인덱스가 설정돼있지않다면 Hash Join이 유리하다.
애초에 Hash 조인은 해시함수를 실행한 값으로 조인을 판별하기 때문에 어떠한 정렬도 필요없다. 해시테이블 자체가 key로 value에 접근하기때문에 정렬될 필요가 없다.







Nested Loop은 시간 복잡도가 O(N*M)이다. Hash, Merge 조인은 O(N+M)이기때문에 시간 성능 차이가 크다.

우리의 쿼리는 



# 분포도 - 해시충돌
	•	균일한 분포의 예: 예를 들어, 조인 키가 고객 ID와 같은 고유 식별자일 경우, 고객 ID는 고르게 분포될 가능성이 높습니다. 이 경우 Hash Join이 각 고객 ID에 대해 균등하게 해시 버킷을 할당할 수 있으므로 조인이 빠르게 수행됩니다.
	•	불균형 분포의 예: 반면, 조인 키가 성별과 같은 범주형 데이터라면, 예를 들어 남성(M)과 여성(F)이 두 가지 값만 있다면, 해시 테이블은 두 개의 버킷에 모든 데이터를 몰리게 할 수 있습니다. 이 경우 성능이 떨어질 수 있습니다.

# 큰조인키
큰 크기나 복잡한 조인 키의 경우: 직접적인 비교 작업은 시간이 많이 걸리고 비효율적일 수 있습니다. 그러나 Hash Join은 이러한 조인 키를 고정된 크기의 해시 값으로 변환하여, 비교 작업을 단순하고 빠르게 처리할 수 있습니다. 따라서 조인 키가 크거나 복잡할수록, Hash Join이 이러한 상황에서 더 효과적이고 빠른 조인 방법이 될 수 있습니다.


조인 키가 복잡하면 쓰기 좋다. 왜냐하면 함수에 돌리면 끝이니깐.
해시 값은 조인 키의 원본 크기와 상관없이 고정된 크기로 변환되므로

조인키의 분포도가 높아야 쓸만하다. 고유키를 가지면 아주 좋다.
그런데 조인키를 ID로 하는게 아니라 다른걸로 해버린다면 같은 해시값을 반환하는 데이터가 많아진다. 같은 해시값을 가진 데이터가 많다는건 하나의 해시 버킷에 여러개의 값이 저장된다는 건데 그렇게 되면 해시값을 얻은 후 한번더 


Join 키가 복잡하면 비교하기 힘드니 좋지 않다
이러한 조인 키를 직접 비교하는 것은 많은 CPU 자원을 소모하게 됩니다.


