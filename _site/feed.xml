<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>김문규블로그</title>
    <description>Node.js 백엔드 개발자</description>
    <link>http://0.0.0.0:4000//</link>
    <atom:link href="http://0.0.0.0:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 10 Feb 2026 22:33:00 -0600</pubDate>
    <lastBuildDate>Tue, 10 Feb 2026 22:33:00 -0600</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>Node.js의 스트림 배압 처리 고도화 (Observable의 한계점)</title>
        <description>&lt;p&gt;LLM 응답 스트리밍 서버가 OOM(Out of memory)으로인해 꺼져버리는 현상이 간간히 로그에 찍혀있었다.&lt;/p&gt;

&lt;p&gt;기존 서버는 llm 응답값을 sse로 스트리밍해주는 서버다. 단순히 @Sse 데코레이터에 Observable을 리턴하는 형식으로 구현되어있다. 단순화하면 아래 구조로 표현할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream API server –(subscribe)–&amp;gt; Redis pubsub  &amp;lt;–(push)– llm 워커에서 llm 응답값 전달&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;@Sse가 알아서 헤더 설정도 해주고 응답값도 잘 정리해주고, 커넥션 에러도 잘 처리해주기때문에 초기 구현에는 좋았지만. 트레픽이 몰릴때는 백프레셔 문제가 발생했다. 아래 코드는 아주 간단한 @Sse 구현 코드다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Sse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;chat-message/:messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;getLlmAnswer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MessageEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;redisService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`llm:answer:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 서버에 동시에 많은 트레픽을 쏴버리면 아래처럼 OOM 에러가 발생하면서 서버가 종료된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 46MB
server-1  | Heap Total: 59MB
server-1  | RSS: 114MB
server-1  | External: 5MB

~

server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 155MB
server-1  | Heap Total: 199MB
server-1  | RSS: 246MB
server-1  | External: 17MB
server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 165MB
server-1  | Heap Total: 210MB
server-1  | RSS: 244MB
server-1  | External: 5MB
server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 174MB
server-1  | Heap Total: 222MB
server-1  | RSS: 261MB
server-1  | External: 13MB
server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 183MB
server-1  | Heap Total: 234MB
server-1  | RSS: 278MB
server-1  | External: 21MB
server-1  | ======================
server-1 exited with code 137  # OOM 발생
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;몰린 트레픽으로 인해 메모리 사용량이 확 올라 서버가 갑자기 꺼져버린다.&lt;/p&gt;

&lt;h2 id=&quot;observable의-한계&quot;&gt;Observable의 한계&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Observable은 백프래셔가 제대로 구현돼있지 않다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Node.js Stream은 메모리를 적당량만 꾸준히 이용하는 선에서 안정성을 유지한다고 알고있었는데 Observable 내부를 까보니 단순히 Observable에 데이터 소스를 연결해두면 &lt;strong&gt;Observable 내부 버퍼에 데이터가 계속 쌓이는 문제&lt;/strong&gt;가 발생한다. 클라이언트가 데이터를 정상적으로 받고 있다면 문제가 되지않지만 클라이언트에서 데이터를 받을수 없는 상황이 오면 데이터를 멈추지않고 메모리에 계속 쌓는 상황이었다. 그러다 OOM 이 발생했다.&lt;/p&gt;

&lt;p&gt;Observable이 작동하는 방식을 파악해보니 아래와 같았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;데이터소스 -&amp;gt; observer.next() -&amp;gt; [RxJS 전용(concatMap) 버퍼] -&amp;gt; [WritableStream 버퍼] -&amp;gt; [Socket 버퍼]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nest.js 자체적으로&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;TCP socket 버퍼에 데이터가 꽉차면 writableStream 버퍼에서 데이터를 안보내게 되고.&lt;/li&gt;
  &lt;li&gt;WritableStream 버퍼에 데이터가 꽉차면 RxJS 전용 버퍼에서 데이터를 안보내게 된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;하지만 RxJS의 버퍼에서는 데이터가 꽉찼는지아닌지 확인하는 로직이 따로 없다.&lt;/strong&gt; 
그러다보니 당연하게도 Out Of Memory가 발생할수 밖에 없었다. 클라이언트쪽이던 서버쪽이던 네트워크문제가 생긴다면 어쩔수 없는거였다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;push-매커니즘이기때문에&quot;&gt;Push 매커니즘이기때문에&lt;/h3&gt;
&lt;p&gt;이 문제의 근본 원인은 Observable, RxJS 자체가 Push 매커니즘이기때문이라고 한다.
Observable 다큐먼트를 들어가면 뜬금없게도 pull, push 에 대한 내용부터 나온다. &lt;a href=&quot;https://rxjs.dev/guide/observable&quot;&gt;Observable Document&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Push&lt;/strong&gt; 매커니즘은 데이터 송신측에서 보낼 수 있다면 어떠한 상황도 상관없이 그냥 보내는 구조.
&lt;strong&gt;Pull&lt;/strong&gt; 매커니즘은 데이터 수신측에서 받고 싶을때만 받도록 하는 구조다. (Kafka가 그래서 안정성이 좋다고들한다)&lt;/p&gt;

&lt;h3 id=&quot;왜-push-매커니즘을-사용하는지&quot;&gt;왜 push 매커니즘을 사용하는지&lt;/h3&gt;
&lt;p&gt;근본적으로 메모리에 대해선 불안전한 편인데 왜 Push 매커니즘을 쓰는지 찾아보니 RxJS자체가 프론트엔드 이벤트 처리용으로 만들어졌기때문이라고 한다. 이벤트가 언제 발생한지 알수 없기때문에 pull 방식은 불가능하다. JS가 callback을 이용하는 이유와 거의 같지않나 생각이 든다.&lt;/p&gt;

&lt;h2 id=&quot;해결책&quot;&gt;해결책&lt;/h2&gt;
&lt;p&gt;해결책은 간단하다. &lt;strong&gt;@Sse() 데코레이터 + Observable 조합&lt;/strong&gt;에서 &lt;strong&gt;Response 객체&lt;/strong&gt;를 직접 이용하는 방식으로 전환하면 된다. 그리고 데이터소스 또한 &lt;strong&gt;Pull&lt;/strong&gt; 방식의 도구로 변경해야한다. (Redis PubSub은 push 방식이기때문에 Pull 방식인 Redis Stream으로 전환했다.)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;제일 중요한점은 Response객체를 이용해서 클라이언트의 상태를 파악하는 것이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;res.write()는 응답값으로 더 데이터를 받을수 있는지 아닌지 여부를 리턴해준다.&lt;/strong&gt;
이값이 true일 때만 데이터를 계속 받아와서 전달할지 말지 코드를 짜면 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pull 방식으로 전환&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Redis Pubsub에서 Redis Stream으로 변경했기때문에 특정 시점부터 데이터를 받아올수 있다.(XREAD).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;그리고 “drain” 이벤트 구독&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;클라이언트가 데이터를 받을수 없는 상태라면 res.write() 가 false를 응답하기때문에 송신프로세스를 멈추고 대기해야한다. 그리고 drain 이벤트가 발행하면 그때 다시 보내면 된다.
drain(배수라는 뜻) 물이 빠졌으니 데이터를 다시 보내라는 신호다.&lt;/p&gt;

&lt;p&gt;아래는 변환된 샘플 코드다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// pseudo code&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;chat-message/:messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getLlmAnswer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// @Sse 를 안쓰기 때문에 직접 다 설정해야함.&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Content-Type&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;text/event-stream&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Cache-Control&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;no-cache&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;keep-alive&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;X-Accel-Buffering&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flushHeaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;streamKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`llm:answer:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lastId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;disconnect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;redisService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;streamKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lastId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;lastId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canWrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`data: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;\n\n`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// 백프레셔: 버퍼 가득 차면 &quot;drain&quot; 대기&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;canWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;drain&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;writableEnded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;res.write(), ‘drain’ 이벤트만으로도 부하를 조절할수 있는 구조가 됐다.&lt;/p&gt;

&lt;p&gt;동일한 테스트를 실행하면 동일한 요청수에 OOM 이 발생하지않는다. 물론 요청수가 늘어나면 하드웨어가 제한돼어있으니 메모리 문제가 발생하지만 이건 하드웨어 수평확장으로 진행하면 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 10 May 2025 00:00:00 -0500</pubDate>
        <link>http://0.0.0.0:4000//sse-and-observable-limitation-on-memory</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//sse-and-observable-limitation-on-memory</guid>
        
        <category>Nest.js</category>
        
        <category>Stream</category>
        
        <category>Observable</category>
        
        <category>RxJS</category>
        
        
      </item>
    
      <item>
        <title>카프카 프로듀서 필수 설정값</title>
        <description>&lt;p&gt;기본적인 프로듀서 설정값들을 정리한 글이다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;실무에서 쓰일만한 설정값들을 대충 훑어보고 개념으로 넘어가자.&lt;/p&gt;

&lt;p&gt;마이크로서비스에서 카프카를 이용할 때는 속도가 중요하다. 그럴 때는 아래와 같은 설정이 필요하다.&lt;/p&gt;
&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 마이크로서비스&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32768&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;linger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;acks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;per&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;idempotence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;compression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;snappy&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반면에 로그를 처리하는 용도로 카프카를 이용한다면 아래와 같은 설정이면 충분하다.&lt;/p&gt;
&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 로깅용&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;262144&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;linger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;acks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;per&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;idempotence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;compression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;zstd&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 6가지 설정은 아주 기본적인 프로듀서 옵션들인데 성능 vs 안정성에 따라 위 옵션들의 값이 바뀌게 된다.&lt;/p&gt;

&lt;p&gt;하나하나 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사전 지식&lt;/strong&gt;
Record: 하나의 이벤트, 하나의 메시지.
Batch: Record 묶음. 카프카는 보통 이벤트 하나하나를 전송하지않고 Batch로 묶어서 보낸다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;한번-메시지-보낼때-얼마나-보낼지&quot;&gt;한번 메시지 보낼때 얼마나 보낼지&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;“batch.size”&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;프로듀서가 메시지를 보낼 때의 최대 크기를 설정한다. 기본 값은 16KB.&lt;/p&gt;

&lt;p&gt;기본적으로 프로듀서는 메시지를 보내기전에 batch buffer에 쌓는다. 그리고 batch.size 값에 도달하면 바로 전송된다. 혹은 아래 설명할 linger.ms 시간에 도달하면 batch.size에 도달하지않아도 브로커로 batch를 전송된다.&lt;/p&gt;

&lt;p&gt;당연하게도 프로듀서와 브로커 간의 커뮤니케이션이 많으면 많아질수록 하드웨어에 부담이 늘어난다. 커뮤니케이션 횟수가 많아지면 네트워크 부하는 당연히 커지고. “네트워크 패킷 -&amp;gt; 카프카 객체”로 직렬화하는 일도 많아지니 CPU 사용량도 늘어난다.&lt;/p&gt;

&lt;p&gt;그래서 신속한 처리가 필요할 때는 batch.size를 작게 설정한다.&lt;/p&gt;

&lt;p&gt;카프카가 마이크로서비스에서 이용된다면 batch.size를 최소화(32kb이하)해서 이용하고 로그처리와 같이 급하지않은 것들은 꽤 큰 값(256kb 정도)을 이용한다.&lt;/p&gt;

&lt;h1 id=&quot;메시지를-얼마-시간-동안-모아서-보낼까&quot;&gt;메시지를 얼마 시간 동안 모아서 보낼까&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;“linger.ms”&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;batch.size랑 똑같다고 생각하면 된다. 다만 사이즈가 아니라 시간일뿐이다. batch를 보내는 텀을 설정하는 옵션이고.
작게 설정하면 batch.size 설정 값만큼 데이터가 차지않아도 시간이 되면 batch를 보낸다. 나머지는 똑같다.&lt;/p&gt;

&lt;h1 id=&quot;보낸-메시지를-잘-저장했는지-확인&quot;&gt;보낸 메시지를 잘 저장했는지 확인&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;“acks”&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;acks는 브로커가 메시지를 저장한 후, 프로듀서에게 응답을 보내는 조건을 설정하는 옵션이다. 기본값은 1이다.
초반엔 헷갈릴수 있는 점이 하나 존재한다. acks는 몇개의 복제본을 만드는지에 대한 설정이 아니라, “전체 복제본 생성 과정중에 몇개의 복제본이 생긴 뒤에 응답하느냐”를 설정하는것이다. 아직도 비슷하다 느낄수 있어 더 설명하자면 
카프카에서 복제본은 ISR 갯수만큼 만들게 된다. ISR이 복제본을 만드는 과정에서 &lt;strong&gt;몇개를 만든 시점에&lt;/strong&gt; 프러듀서에게 응답을 보낼까 라는 설정이다. ISR 갯수가 5개일때 acks가 1개라면 ISR 5개 모두 복제본 생기는 와중에 1개만 복제되면 응답을 보낸다. 카프카는 브로커 시작 시 설정된 “replication.factor” 값만큼 메시지의 복제본을 만든다. replication.factor만큼 복제하기전에 acks 설정값만큼 복제되면 중도에 미리 응답하게 된다.&lt;/p&gt;

&lt;p&gt;이 값을 작게 하면 리더만 저장해도 되므로 처리 속도가 빠르지만, 리더 브로커가 망가졌을 때 데이터 유실 위험이 있다.
반면, 크게 설정하면 ISR(동기화된 복제본) 모두가 저장해야 응답을 보내므로 속도는 느리지만 안정성이 높아진다.&lt;/p&gt;

&lt;p&gt;설정 가능값은 0, 1, all. 3가지 존재한다.&lt;/p&gt;

&lt;h1 id=&quot;프로듀서가-동시에-몇개의-메시지를-보낼수-있는지-설정하기&quot;&gt;프로듀서가 동시에 몇개의 메시지를 보낼수 있는지 설정하기.&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;“max.in.flight.requests.per.connection”&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;max.in.flight.requests.per.connection 설정이 작동하는 방식은 꽤나 재밌다.
이 설정은 파티션이 얼만큼의 메시지를 동시에 보낼 수 있는지 조절하는 설정값이다. 기본 값은 5로 설정돼있다. 값이 5로 설정돼있다면 동시에 진행될수 있는 메시지 전송 프로세스는 최대 5개로 제한된다.
조절하는 방식은 Queue를 이용한다. 설정값만큼의 길이를 가지는 in.flight.queue가 따로 존재한다. 그리고 프로듀서가 메시지를 보내기전에 queue에 메시지를 넣을수 있는지 확인한다. (queue.length &amp;lt; max.in.flight.request.per.connection 값) 전달이 시작된 메시지들은 in.flight 큐로 들어가게 되고 완료 처리 될때까지 queue안에서 관리된다.&lt;/p&gt;

&lt;p&gt;기본 작동 방식은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. in flight 큐에 들어가있는 메시지 갯수가 max.in.flight.requests.per.connection 수보다 작은지 확인한다.
2. 작다면 브로커에 메시지를 보내고 in flight 큐에 넣는다.
3. 브로커에서 ask를 받았다.
4. 프로듀서에서 브로커에 전달 완료했음을 처리한다.
5. 완료 처리된 메시지는 queue에서 제거한다.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 중요한 점은 다른 설정들에 따라 작동방식이 달라진다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. “acks”에 따른 변화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;acks = 0&lt;/strong&gt;
이 경우에는 브로커가 메시지를 받았다는 응답을 기다리지않는다. 프로듀서에서 브로커에 메시지를 보내버리고 끝이다. (브로커가 제대로 받던 말던 신경안씀) 그렇기때문에 이 상황에서는 max.in.flight 설정이 무의미해진다. queue를 확인하는 절차도 queue에 메시지를 넣는 작업도 하지않게된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;acks &amp;gt; 0&lt;/strong&gt;
이 경우에는 프로듀서는 브로커가 메시지를 잘저장했는지에 대한 응답을 기다리기때문에 메시지를 전송하고 해당 응답을 기다리게된다. 응답을 기다리는 곳이 in.flight.queue인 것이다. 그러므로 in.flight 옵션이 정상 작동된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. enable.idempotence에 따른 변화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;enable.idempotence == true&lt;/strong&gt;
이 경우가 꽤나 재미있다. true로 설정돼있을 때는 메시지 전송시에 sequence number를 같이 보내고 브로커로부터 완료 메시지를 받을 때도 동일한 sequence number를 받게된다. 
in.flight 큐에 들어간 순서대로 sequence number가 커지게 되니까 당연히 head(맨앞) 값이 제일 작다. 이때 여러개의 메시지를 비동기로 같이 보내지만 순서의 안정성을 이룰수 있는 방법이 생기게된다.
브로커로 받은 메시지의 sequence number가 큐 맨앞(head)의 sequence number보다 크다면 순번이 후순위이기 때문에 head의 메시지가 완료되기까지 보류된다.&lt;/p&gt;

&lt;p&gt;후순위가 먼저 응답됐을 때 보류됨으로써 얻어지는 이점은 꽤나 강력하다. “선순위의 메시지가 완료되어 큐에서 빠지기전까지는 후순위 메시지들도 빠질수 없기때문에 보내는 양이 자동으로 조절된다.” 인프라 관리 측면, 순서 관리측면에서 알아서 안정화되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;enable.idempotence == false&lt;/strong&gt;
이 경우에는 sequence number를 이용하지않는다. 그러므로 먼저 응답온 메시지는 큐에서 먼저 빠진다. 순서 보장도 없고 중복 방지도 불가하다. 단순히 동시에 보내는 갯수만 조절할뿐이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(참고) true일 때는 max.in.flight 값이 5 이하로 강제된다. 5이상이라면 OutOfOrderSequenceException 가 발생할 확률이 너무 높아진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;batch를-압축해서-보낼지-어떤-종류로-압축할지&quot;&gt;batch를 압축해서 보낼지. 어떤 종류로 압축할지&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;“compression.type”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;가능한 값으로는 none, gzip, snappy, lz4, zstd. 최근 버전에서는 zstd(Zstandard)를 권장한다고 한다.
압축 단위는 당연히 batch이다.&lt;/p&gt;

&lt;p&gt;보통 snappy, lz4 알고리즘이 빠르게 압축해야할 때 이용된다. 마이크로서비스와 같이 응답이 빨라야할때 이용. 
gzip, zstd는 압축률이 커야할 때 이용한다. 로깅 처리와 같이 천천히 해도 될때 이용.&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Jan 2025 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//kafka-producer-options</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//kafka-producer-options</guid>
        
        <category>Kafka</category>
        
        
      </item>
    
      <item>
        <title>Cold Data - 거의 이용되지않는 데이터 관리</title>
        <description>&lt;p&gt;거의 이용되지않는 데이터 관리 [오래된 데이터 저장 - append-only 데이터 처리]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스가 커지면서 데이터가 나날이 늘어간다. 일단은 데이터베이스 샤딩으로 해결하려고 하지만 한계가 명확하다. 그리고 제일 중요한 비용이 너무 커져버린다. 이럴 때 데이터를 어떻게 저장하고 이용할지에 대해 정리하는 글이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우리가 신경써야할 데이터의 종류는 크게 두가지로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1.일년에 몇번 간간히 검색을 하긴 하는 데이터. (High-value Cold Data)&lt;/li&gt;
  &lt;li&gt;2.통계용으로만 쓰이고 유저들이 직접 이용하지는 않는 데이터. (Cold Data)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번은 배달앱에서 5년전에 주문했던 데이터라고 생각하면 된다. (유저가 주문내역에서 스크롤을 엄청 내리거나 특정 연월을 검색했을 때만 나오는 데이터)&lt;br /&gt;
2번은 유저 행동에 관한 것들. 로그 데이터가 대표적이다.&lt;/p&gt;

&lt;p&gt;위 두가지 데이터들을 DB에 저장하는 것은 부담이 아주 크다. 아무리 샤딩을 잘해둔다고 해도 성능적으로 악영향을 줄수 있고 가장 큰 단점으로 비용이 커진다. 그래서 S3와 같은 곳에 옮겨두고 필요할 때 불러와서 처리해야한다.&lt;br /&gt;
이런 데이터들을 &lt;strong&gt;Cold Data&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;1-간간히-검색되는-데이터-high-value-cold-data&quot;&gt;1. 간간히 검색되는 데이터 “High-value Cold Data”&lt;/h2&gt;

&lt;p&gt;쇼핑몰 유저가 5년전에 주문한 내역을 DB에 저장해두고 최근 주문내역을 조회할 때 같이 돌리게 하는 건 성능적으로나 비용적으로 좋지않다. 자주 이용되는 데이터와 자주 이용되지않는 데이터는 분리해서 저장해야한다.&lt;/p&gt;

&lt;p&gt;예를 들어 쇼핑몰에서 주문 데이터들은 처음 생성됐을 시 일반적인 DB(MySQL, MongoDB)에 저장된다. 그리고 이용되지 않는 시기가 오면 S3로 옮겨지며 Cold Data로 관리된다. 그리고 엄청 오래된 데이터라고 판단되면 + 법적으로 문제가 없다면 영영 지우기도 한다. (서비스마다 데이터 관리 정책에 따라 다름)&lt;/p&gt;

&lt;p&gt;오래된 데이터들중에 유저가 간간히 조회하게 되는 데이터들이 있는데 이 데이터들을 &lt;strong&gt;High-value Cold Data&lt;/strong&gt;라고 한다. 쇼핑몰에서 5년전, 10년전 주문내역을 가져올 때 간혹 응답이 느릴 때가 있다. pagination 기능을 잘못 구현해서 느린걸수도 있지만 시스템이 잘구축된 곳이라면 S3에서 데이터를 가져오기 때문에 느린 걸수도 있다.&lt;/p&gt;

&lt;p&gt;“High-value Cold Data”가 관리되는 방식을 좀더 알아보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 쇼핑 주문 데이터가 생성된다.
2. 주문 데이터가 일반 DB에 저장된다.
3. 주문을 한지 몇달이 지난다. 몇달이 지나면 더이상 주문 데이터에 대해 &quot;수정 작업이 불가&quot;해진다.
4. 주문 전체 작업이 완료된지 몇년이 지났다.
5. 정기적으로 실행되는 cold-data 변환 프로세스에서 해당 데이터를 S3로 옮긴다.
6. 주문 데이터가 일반 DB에서 삭제된다.
7. 유저가 해당 데이터를 조회하면 S3에서 가져와서 보여준다.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;읽기-전용-데이터&quot;&gt;“읽기 전용 데이터”&lt;/h4&gt;

  &lt;p&gt;여기서 중요한점은 cold-data로 저장되는 데이터는 모두 수정작업이 불가능하다는 점이다. &lt;strong&gt;서비스 기능적으로 수정을 불가능하게 막는 프로세스가 필요하다.&lt;/strong&gt; 그후 콜드 데이터로 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;데이터-변환저장-과정&quot;&gt;데이터 변환/저장 과정&lt;/h3&gt;

&lt;p&gt;보통 크론잡 + 메시지 큐 방식으로 변환한다. 정기적으로 특정 기간 이상된 데이터들을 조회하여 변환 큐에 넣고 처리한다.&lt;br /&gt;
데이터 크기에 따라 저장방식이 다르다. 데이터 하나하나의 크기가 크다면 데이터 하나하나를 파일로 저장하고 데이터 하나하나의 크기가 작다면 하루에 생기는 데이터를 하나의 파일로 저장한다. 혹은 일주일, 한달 단위로 저장할 수도 있다.&lt;br /&gt;
&lt;strong&gt;그리고 S3 사용 용량을 줄이기 위해 압축하여 저장한다.&lt;/strong&gt; 파일 하나의 사이즈가 너무 커지면 데이터를 조회할 때 가져오는데 걸리는 시간 + 압축을 해제하는 시간 + 파싱하는 시간이 너무 오래걸린다. 적절한 사이즈로 저장될수 있는 기간의 데이터를 하나의 파일로 만들어 저장해야한다.&lt;/p&gt;

&lt;h3 id=&quot;맵핑-테이블&quot;&gt;맵핑 테이블&lt;/h3&gt;

&lt;p&gt;S3에 저장된 파일은 파일 이름으로 조회할 수 있지만 파일 이름만으로는 조회가 어렵다. 그래서 맵핑 테이블을 만들어 파일 이름과 파일 내용을 맵핑해둔다.&lt;/p&gt;

&lt;h4 id=&quot;기본-방식&quot;&gt;기본 방식&lt;/h4&gt;

&lt;p&gt;S3에 저장됐다면 따로 맵핑 데이터를 DB에 만들어야한다. 기본 형식은 아래와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;주문번호&lt;/th&gt;
      &lt;th&gt;s3Key&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10004&lt;/td&gt;
      &lt;td&gt;userId_2011_01_13.jsonl.gz&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;버퍼-오프셋--range-get-방식&quot;&gt;버퍼 오프셋 + Range GET 방식&lt;/h4&gt;

&lt;p&gt;S3에 파일 갯수가 너무 많아지는게 안좋아질 때도 있다. 분석 처리할 때 파일이 너무 많으면 오래걸리기도 하고 S3에 쓰기 처리를 너무 많이하면 안좋기도 하다. (S3는 쓰기 비용이 읽기비용의 10배정도 비싸다고 한다.) 이럴 때는 하나의 파일 크기를 크게 하는 대신 맵핑 테이블에서 구획을 나눠 관리한다. &lt;strong&gt;offset&lt;/strong&gt;을 추가로 저장하는 방식이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;주문번호&lt;/th&gt;
      &lt;th&gt;s3Key&lt;/th&gt;
      &lt;th&gt;byteOffsetStart&lt;/th&gt;
      &lt;th&gt;byteOffsetEnd&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10004&lt;/td&gt;
      &lt;td&gt;userId_2011_01_13.jsonl&lt;/td&gt;
      &lt;td&gt;1829382&lt;/td&gt;
      &lt;td&gt;1830123&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10005&lt;/td&gt;
      &lt;td&gt;userId_2011_01_13.jsonl&lt;/td&gt;
      &lt;td&gt;1830123&lt;/td&gt;
      &lt;td&gt;1830864&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10006&lt;/td&gt;
      &lt;td&gt;userId_2011_01_13.jsonl&lt;/td&gt;
      &lt;td&gt;1830864&lt;/td&gt;
      &lt;td&gt;1831605&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 처럼 여러 주문을 하나의 파일로 저장하고 시작점, 끝 점을 저장해둬 해당하는 부분만 S3에서 받아올 수 있다.&lt;br /&gt;
&lt;strong&gt;Range GET&lt;/strong&gt;이라고 하는데 기존 받아오던 쿼리에 Range 파라미터만 추가하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const s3 = new S3Client({ region: &quot;ap-northeast-2&quot; });

const command = new GetObjectCommand({
  Bucket: &quot;your-bucket-name&quot;,
  Key: &quot;your-file.jsonl&quot;,
  Range: &quot;bytes=1829382-1830123&quot;,
});

const response = await s3.send(command);
const stream = response.Body;
const data = await streamToString(stream);

~
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Range 방식의 단점이 하나 있다. offset으로 필요한 데이터만 가져와야하기때문에 파일을 압축해서 저장해놓지 못한다. 압축해 놓은 파일에서 부분만 가져오는건 불가능하니말이다. 압축하지않아도 부담이 되지않는 상황에서만 이용할수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-통계용으로만-쓰이는-데이터-cold-data&quot;&gt;2. 통계용으로만 쓰이는 데이터 “Cold Data”&lt;/h2&gt;

&lt;p&gt;유저한테 보이지않는 데이터들 주로 유저행동 분석에 쓰이는 데이터들이다. 이 데이터들은 특별한 경우가 아니라면 디비에 저장되지않고 바로 로그 파일로 관리된다.&lt;/p&gt;

&lt;p&gt;“일반 Cold Data”가 관리되는 방식은 간단하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 유저 행동 로그가 생성된다.
2. 개별 서버 인스턴스에서 로그 파일로 저장된다.
3. 적당한 버퍼 크기로 정기적으로(보통 수초 이내로) 중앙 로그 서버로 전송된다.
4. 일정기간 분석용 툴에 저장된다. (ELK, Clickhouse 등)
5. 분석 완료, 혹은 더이상 필요하지 않은 데이터는 S3로 옮겨진다.
6. 기간이 오래된 데이터라면 S3에서도 제일 저렴한 타입으로 옮겨진다.
7. 법적, 서비스 정책에 따라 데이터가 삭제된다.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반 Cold Data는 High-value Cold Data와 다르게 수정을 불가능하게 하는 프로세스가 따로 존재하지 않는다. 어차피 로그 데이터라 수정할 일이 없다.&lt;/p&gt;

&lt;h2 id=&quot;공통-내용&quot;&gt;공통 내용&lt;/h2&gt;

&lt;h3 id=&quot;jsonl&quot;&gt;JSONL&lt;/h3&gt;

&lt;p&gt;High-value Cold Data, 일반 Cold data 모두 보통 JSONL 형식으로 저장된다. append-only 방식에서 대부분 쓰인다. 기본적으로 ,(컴마) 없이 줄바꿈으로 구분되어 한줄한줄이 하나의 json데이터다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{&quot;userId&quot;: &quot;u1&quot;, &quot;action&quot;: &quot;login&quot;, &quot;timestamp&quot;: &quot;2025-06-01T10:00:00Z&quot;}
{&quot;userId&quot;: &quot;u2&quot;, &quot;action&quot;: &quot;purchase&quot;, &quot;timestamp&quot;: &quot;2025-06-01T10:05:00Z&quot;, &quot;item&quot;: &quot;keyboard&quot;}
{&quot;userId&quot;: &quot;u1&quot;, &quot;action&quot;: &quot;logout&quot;, &quot;timestamp&quot;: &quot;2025-06-01T10:10:00Z&quot;}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 줄마다 하나의 데이터이기 때문에 위에서 설명한 “버퍼 오프셋 + Range GET 방식”에 line 값을 추가해서 이용하기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;s3-수명-주기&quot;&gt;S3 수명 주기&lt;/h3&gt;

&lt;p&gt;S3도 가격이 천차만별이다.&lt;br /&gt;
Standard, Standard-Infrequent Access, Archive(Glacier) 등 여러가지가 있다. &lt;a href=&quot;https://aws.amazon.com/ko/s3/storage-classes/&quot;&gt;링크&lt;/a&gt;로 한번 훑어보면 좋다.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Mar 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//cold-data</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//cold-data</guid>
        
        <category>Nest.js</category>
        
        <category>Dtabase</category>
        
        
      </item>
    
      <item>
        <title>Temporal.io 개발/운영 팁</title>
        <description>&lt;p&gt;데이터 오케스트레이션 툴로 Temporal를 운영하면서 얻은 팁들을 정리한다. Temporal의 기본적인 구조는 알고 있어야 이해가 가능한 글이다.&lt;/p&gt;

&lt;p&gt;Temporal의 목적은 작기적으로 실행되는 프로세스를 안정적으로 완료하는 것이다. 이를 중심으로 팁들이 구성된다.&lt;/p&gt;

&lt;h3 id=&quot;1-엑티비티는-최대한-작게-만든다-하나의-일만-하게-한다&quot;&gt;1. 엑티비티는 최대한 작게 만든다. 하나의 일만 하게 한다.&lt;/h3&gt;
&lt;p&gt;Temporal은 “장기적으로 실행되는 프로세스를 안정적으로 완료”하는게 목적이다보니 재실행 프로세스가 정말 안정적이다. 어떠한 장애가 발생하더라도 가장 마지막에 엑티비티 바로 다음부터 실행된다. 그렇기때문에 하나의 엑티비티가 하는 일이 많아진다면 중복실행될 확률이 높아진다. 예를 들어 3가지 일을 하는 엑티비티A가 존재할 때, 엑티비티A 진행 과정에서 2개의 일을 완료하고 1개의 일이 남았을 때 장애가 발생한다면 Temporal은 다시 엑티비티A부터 실행하기때문에 이미 완료한 2개의 일을 다시 실행하고 나머지 하나의 일을 실행하게 된다.&lt;/p&gt;

&lt;h3 id=&quot;2-중복-실행-여부를-확인하는-코드는-최소화한다&quot;&gt;2. 중복 실행 여부를 확인하는 코드는 최소화한다.&lt;/h3&gt;
&lt;p&gt;첫번째 팁의 연장선이다. 하나의 엑티비티가 하나의 일만하는 구조가 아니라면 어쩔수 없이 엑티비티 내부의 작업들이 이미 실행됐는지 확인하는 코드를 추가하게 된다. Temporal는 순서를 보장해주는 게 최대 장점이기때문에 엑티비티를 최대한 작게 만들어 중복실행 확인 코드를 최소화하자. 이게 Temporal 장점을 극대화하는 일이다. 그리고 “중복확인을 하는 코드 하나정도야 추가해도 되지않나? 함수 실행전에 한줄 추가하면 되는거 아닌가?” 생각할수 있다. 하지만 중복 확인 코드가 하나둘 쌓이다보면 어느새 코드 유지보수가 힘들어지고 전체 흐름을 파악하는게 힘들어진다.&lt;/p&gt;

&lt;p&gt;다만 정말 중요한 데이터여서 특정조건에만 단 한번 실행되거나 만들어져야 하는 것이라면 중복 코드를 추가하는 게 좋다.&lt;/p&gt;

&lt;p&gt;중복 코드가 많아지면 Temporal를 이용하는 장점이 거의 사라진다고 할수 있다. Kafka나 RabbitMQ로 이벤트 하나하나 실행시키는 것과 크게 다를 바가 없기때문이다. 큰장점이 없는데 새로운 기술 스택을 하나 추가하는 건 큰 낭비다.&lt;/p&gt;

&lt;h3 id=&quot;3-워크플로우의-입력값은-dto를-이용하여-구조화-하고-순수-객체로-만들어야-한다&quot;&gt;3. 워크플로우의 입력값은 DTO를 이용하여 구조화 하고 순수 객체로 만들어야 한다.&lt;/h3&gt;
&lt;p&gt;Temporal의 워크플로우간의 데이터 전달, 엑티비티간의 데이터 전달에 데이터를 직렬화/역직렬화한다. 그래서 전달 값으로 객체를 이용하면 원하는대로 전달이 안되는 경우가 있다. 메서드는 당연히 전달안된다. 정말 값만을 DTO로 구조화하여 전달해야한다. 특히나 Nest.js에서 이용하는 데코레이터들을 이용하면 의도한대로 작동하지않기때문에 이용하지않아야한다.&lt;/p&gt;

&lt;h3 id=&quot;4-워크플로우-체인을-만든다면-단방향으로-구조화하는게-편하다&quot;&gt;4. 워크플로우 체인을 만든다면 단방향으로 구조화하는게 편하다.&lt;/h3&gt;
&lt;p&gt;기능을 구현하다보면 워크플로우가 다른 워크플로우를 실행하는 구조가 만들어지게 된다. 기눙 재활용이 가능해져서 좋긴하지만 만들다보면 순환적으로 워크플로우를 실행하는 구조가 생기게 된다. 알맞은 상황에 체인을 끊어낼수만 있다면 문제가 되지않지만, 이 또한 유지보수를 어렵게 만들기때문에 지양하는게 좋다. 워크플로우 체인이 필요하다면 하나의 메인 워크플로우를 두고 해당 메인 워크플로우가 서브 워크플로우들을 실행하는 구조로 짜는게 훨씬 유지보수에 편리하다.
그리고 재귀적으로 워크플로우를 실행해야할 때가 있다. 그럴 때는 내 워크플로우를 다시 실행하는 것보다 while문으로 실행하는게 더 모니터링하기 편하다(이건 개인마다 다를수 있으니 만들어보면서 본인의 방식을 찾는게 좋을듯함.)&lt;/p&gt;

&lt;h3 id=&quot;5-워크플로우-코드를-구성할-때-엑티비티-실행이-분기되면-에러가-발생한다&quot;&gt;5. 워크플로우 코드를 구성할 때 엑티비티 실행이 분기되면 에러가 발생한다.&lt;/h3&gt;
&lt;p&gt;처음 만들 때 겪게 되는 문제라 미리 알면 코드를 바꾸지않을수 있어서 좋지않을까해서 적는다.&lt;/p&gt;

&lt;p&gt;Temporal은 “determinism”이란 단어를 강조한다. “결정성”이라고 하는데 “같은 입력이 주어졌을 때 항상 동일한 실행 흐름과 결과가 나오는 성질을 말합니다.” 이라고 한다. 그래서 꼭 같은 순서로 실행되어야 하고 워크플로우안에서는 조건에 따라 분기로 다른 실행 흐름이 생기면 에러가 발생한다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SendNotificationWorkflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;findUserToSendNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;someCondition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sendEmail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 조건에 따라 실행&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logToSlack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 또는 이쪽 실행&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;워크플로우 코드에서는 최대한 간결하게 엑티비티를 순서대로 실행하는 코드만 남겨놓아야한다. 분기는 엑티비티에서 한다. 아래 코드 확인.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SendNotificationWorkflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;findUserToSendNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;someCondition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SendNotificationActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SendNotificationActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sendEmail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 조건에 따라 실행&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logToSlack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 또는 이쪽 실행&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Feb 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//temporal-tips</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//temporal-tips</guid>
        
        <category>Temporal.io</category>
        
        <category>Nest.js</category>
        
        
      </item>
    
      <item>
        <title>서버가 데이터를 받기까지 [epoll] - 서버가 작동하는 흐름 2</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;1.서버가 데이터를 받기까지 [운영체제에서]&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;&lt;u&gt;(현재글) 2.서버가 데이터를 받기까지 [libuv - epoll]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt;
3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt;
4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이전 단계에서 데이터가 “receive socket buffer”에 도착했다. 이제 Node.js 서버가 데이터를 가져와서 처리해야한다. 데이터를 가져오는 일을 해주는 것이 libuv의 한가지 책임 중 하나이다. (가져오는 일이라고 하기보단 서버와 클라이언트간의 연결인 소켓들을 관리해주는 일)&lt;/p&gt;

&lt;p&gt;일단 서버로 향하는 모든 연결은 하나의 소켓으로 가는게 아니다. 여러 클라이언트와 연결되기때문에 연결되는 클라이언트 수만큼 소켓이 생기게 된다. 이렇게 되면 관리해야하는 socket이 꽤나 많아지는데. 이를 관리하는 매커니즘 종류에 따라 IO 성능의 차이가 있다. 고전적인 방법(select, poll)보다 libuv가 탁월히 좋다. (select, poll, libuv 비교는 글 마지막에..)&lt;/p&gt;

&lt;p&gt;socket에서 데이터를 가져오는 것은 libuv의 책임이라고 했다. libuv안에 존재하는 OS별 라이브러리를 이용하여 작동한다. linux는 epoll, windows는 kqueue가 있다. 우리의 서버는 대부분 리눅스에서 돌아가니 “epoll”을 중심으로 파악해보자.&lt;/p&gt;

&lt;p&gt;epoll은 3가지 함수가 핵심이다. &lt;strong&gt;“epoll_create()”, “epoll_ctl()”, “epoll_wait()”&lt;/strong&gt;”.&lt;/p&gt;

&lt;h3 id=&quot;epoll_create&quot;&gt;epoll_create()&lt;/h3&gt;
&lt;p&gt;epoll_create()는 두가지 자료구조를 만든다. &lt;u&gt;첫번째 자료구조는 &quot;연결된 전체 fd 목록&quot;을 가진다.(**Interest list**) 두번째 자료구조는 &quot;새로운 이벤트가 발생한 fd목록&quot;을 가진다.(**ready list**)&lt;/u&gt; node.js 서버가 실행됐을 때 epoll_create() 또한 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;epoll_ctl&quot;&gt;epoll_ctl()&lt;/h3&gt;
&lt;p&gt;새로운 연결이 들어오면 &lt;strong&gt;&lt;em&gt;epoll_ctl()&lt;/em&gt;&lt;/strong&gt; 함수를 이용해서 새로운 FD를 Interest list에 등록한다. 이 등록 과정에서 &lt;em&gt;어떤 작업에 대해 감지&lt;/em&gt;할건지도 명시해주어야 한다. 예를 들어, 새로운 연결이 들어왔을 때는 EPOLLIN 이벤트를 감지하도록 설정해둔다.&lt;/p&gt;

&lt;p&gt;이제 새로운 데이터를 받아오는 셋팅이 완료된 상태이다. 이제 Interest list에 등록된 FD에서 감지중인 이벤트 중 이벤트가 하나라도 발생한다면 ready list에 해당 FD가 추가된다. event_crl() 함수를 이용하여 이벤트 필터링 프로세스를 추가한 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;epoll_wait&quot;&gt;epoll_wait()&lt;/h3&gt;
&lt;p&gt;이제 마지막으로 epoll_wait() 함수가 실행되면 ready list에 있는 FD들을 event loop에 전달한다.&lt;/p&gt;

&lt;h4 id=&quot;epoll_wait-디테일&quot;&gt;epoll_wait() 디테일&lt;/h4&gt;
&lt;p&gt;epoll_create()와 epoll_ctl()은 운영체제단에서 알아서 실행하지만 epoll_wait()는 event loop(libuv)단에서 실행된다. event loop의 &lt;strong&gt;poll phase&lt;/strong&gt;에서 IO 관련된 이벤트들을 처리하는건 이미 알고있을것이다. 그러니 당연히 새로운 IO 또한 poll phase에서 책임진다.&lt;/p&gt;

&lt;p&gt;poll phase내에서 epoll_wait() 함수를 실행하여 새로운 IO가 발생한 fd목록을 가져온다. 하지만 ready list에 어떠한 fd도 존재하지 않는다면 새로운 IO가 생길때까지 기다린다.(그래서 이름에 “wait”이 붙어있다.) 다만 이 기다리는 조건은 상황에 따라 달라진다. 아래 event loop 코드(uv_run())을 보면 다른 phase들과 다르게 uv__io_poll() 함수만 두번째 인자로 timeout을 가지고 있는걸 알수 있다. 이 timeout을 통해 얼마동안 새로운 IO를 기다릴지를 정한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// core.c&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop_flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;can_sleep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv__queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pending_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv__queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idle_handles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__run_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uv__run_idle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uv__run_prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UV_RUN_ONCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can_sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UV_RUN_DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv__backend_timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__metrics_inc_loop_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__io_poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두번째 인자로 타입아웃 값 존재.&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;timeout이 정해지는 조건은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;timeout = 0: poll phase 이전 phase들에 실행할 작업이 있을 때. 기다리지 않고 바로 응답한다.&lt;/li&gt;
  &lt;li&gt;timeout &amp;gt; 0: 이전 phase들 중 timer에만 작업이 있을 때 제일 임박한 작업을 기준으로 timeout이 정해진다.&lt;/li&gt;
  &lt;li&gt;timeout &amp;lt; 0: 이전 phase들 중 어떠한 곳에서도 진행해야할 작업이 없을 때는 무기한 기다린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;왜-이전-phase들만-기준으로-잡는지&quot;&gt;왜 이전 phase들만 기준으로 잡는지?&lt;/h4&gt;
&lt;p&gt;Event loop은 작업 종류에 따라 phase 별로 분리해뒀다. 그리고 정해진 순서에 따라 반복되며 실행된다. &lt;strong&gt;이 순서 자체가 서버 기능의 우선순위와 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Timers - 프로그램이 계획 잡아둔 작업&lt;/li&gt;
  &lt;li&gt;Pending Callbacks - 이전 iteration에서 미뤄진 작업&lt;/li&gt;
  &lt;li&gt;Idle, prepare - node 시스템 내부 작업 처리&lt;/li&gt;
  &lt;li&gt;Poll - IO 처리&lt;/li&gt;
  &lt;li&gt;Check (setImmediate callbacks) - Poll phase 다음에 실행돼야할 작업&lt;/li&gt;
  &lt;li&gt;Close Callbacks - 마무리된 작업에 대한 정리 작업&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;poll-phase-이전&quot;&gt;poll phase 이전&lt;/h4&gt;
&lt;p&gt;1~4번은 한바퀴 전 iteration에서 발생한 IO를 처리하는 목적을 가지고 있다. 먼저 받은 IO부터 우선적으로 처리한뒤 새로운 IO를 받도록 설계되었기 때문에 새로운 IO를 받는 시간(timeout)을 0으로 설정해놓는다. timeout이 0보다 커서 기다리게된다면 이전 IO에 대한 작업이 그만큼 멈춰지게 되기때문이다.&lt;/p&gt;

&lt;h4 id=&quot;poll-phase-이후&quot;&gt;poll phase 이후&lt;/h4&gt;
&lt;p&gt;반면에 “5.check phase”는 setImmediate 콜백들을 처리한다. 그런데 이 setImmediate 자체가 poll phase 바로 뒤에 실행되도록 설계된 함수다. 만들어진 이유가 그러니 당연히 epoll_wait() timeout의 조건에 들어가지 않는다. (setImmediate라는 이름 자체가 잘못지어진게 아닌가 싶다. 처음엔 Immediate인데 왜 poll 뒤에 작동하는지 납득이 안됐다.)&lt;/p&gt;

&lt;p&gt;“6.close phase”는 완료된 작업의 뒷작업이기 때문에 굳이 빨리 처리할 필요가 없다. 그러니 이 또한 timeout에 조건에 들어가지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리가 만드는 서버라는 것 자체가 Input을 받아 처리하는 Output을 전달해주는 것이기 때문에 Input을 받는 전략을 잘짜야한다. Input받는 작업을 계속 실행해주는 것은 당연히 다른 작업을 못하게 되므로 불가하다. 반면 받은 input을 처리하는데 시간을 많이 쏟고 새로운 input을 받는 시간이 적다면 이것 또한 문제다. input받는 시간과 받은 input을 처리하는 시간이 적절히 균형을 이루어야한다. Node.js에서는 이 &lt;strong&gt;timeout&lt;/strong&gt;을 통해 균형을 맞춘다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;epoll_wait-으로-받아온-데이터는&quot;&gt;epoll_wait() 으로 받아온 데이터는.&lt;/h2&gt;
&lt;p&gt;epoll_wait()으로 새로운 IO를 가진 fd목록을 가져왔다. 이 목록을 순회하면서 콜백을 실행시킨다. 이 콜백은 epoll_ctl()를 실행시킬 때 같이 등록해놓은 콜백이다. 데이터를 읽어오거나 에러를 처리하는 콜백이 실행된다.
Node.js에서 socket.on(‘data’, callback); 처럼 실행된다고 보면 간단하다.
&lt;strong&gt;&lt;em&gt;주의해야 할 점은 이 콜백들은 poll phase의 queue에 들어가거나 나오는 작업없이 epoll_wait()에서 응답받자마자 바로 실행된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 libuv에서 받아온 데이터가 http request로 변화할 차례다. 이건 다음글에서 이야기하자.&lt;/p&gt;

&lt;h3 id=&quot;selectpoll-vs-epoll&quot;&gt;Select/Poll VS Epoll&lt;/h3&gt;
&lt;p&gt;끝내기 전에 고전적인 방식(select, poll)과 epoll의 차이점을 간단히 정리해보고 가자.
select, poll의 방식은 서버가 정기적인 시간마다 서버와 연결된 socket들에 변화가 있는지 하나하나 확인한다. socket이 10000개라면 정기적인 시간마다 10000개를 확인하는 것이다. 반면에 epoll은 소켓들을 관리하는 자료구조를 따로 만들고. 소켓에 들어오는 이벤트들을 검사한다. libuv에 전달해줘야하는 이벤트인지 아닌지. 맞다면 관리 자료구조에 해당 fd를 적어둔다. 그리고 정기적으로 서버가 새로운 이벤트에 대해 요청하면 그 데이터만 전달한다. 다른 검사 과정은 없다. 이러니 획기적으로 fd 검사 횟수가 줄어들수 밖에 없다. 처음엔 소켓을 관리하는 데이터를 만들고. 모든 이벤트를 필터링하는 것도 부하가 들지 않을까 생각했지만 필터링 하나 넣는것이 그렇게 큰 부하가 드는 일이 아니라서 월등히 성능이 좋아질수 밖에 없다는 걸 받아들였다.&lt;/p&gt;

&lt;p&gt;필터링 과정이 부하가 되지는 않을까 생각해봤지만 매번 모든 fd를 확인해서 까보는 것에 비하면 비교할수 없을 정도로 부하가 작다.&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Jan 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//from-the-libuv-server-series-2</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//from-the-libuv-server-series-2</guid>
        
        <category>node.js</category>
        
        <category>TCP/IP</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>API 서버가 데이터를 받기까지 (운영체제에서) - 서버가 작동하는 흐름 1</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;&lt;u&gt;(현재글) 1.서버가 데이터를 받기까지 [운영체제에서]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;2.서버가 데이터를 받기까지 [libuv]&lt;/a&gt; &lt;br /&gt;
3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt;
4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;api-서버가-데이터를-받기까지&quot;&gt;API 서버가 데이터를 받기까지.&lt;/h1&gt;
&lt;p&gt;우리가 만든 Node.js 서버가 데이터를 받기위해선 포트 번호(ex. 3000, 8080)와 바인딩되어야한다. 그래야만 운영체제가 node.js 서버 프로그램이 어디 있는지 알수있고 데이터를 보낼수 있다.
이제 포트와 연결된 상태로 서버가 &lt;strong&gt;실행&lt;/strong&gt;중이라면 서버에서는 데이터를 받을 준비가 됐다.&lt;/p&gt;

&lt;p&gt;송신자측을 이야기해보자.
송신자(클라이언트)는 데이터를 보내기전에 서버와 연결을 만들어야한다. 이때 TCP 연결이 필요하다. TCP 연결은 3 way handeshake로 만들어진다. &lt;strong&gt;3 way handshake가 완료되면 클라이언트와 서버에 socket이 생긴다.&lt;/strong&gt; 이 소켓(socket)이라는 건 connection이 가능하다는 증빙이라고 생각하면 된다. 소켓의 내용물는 클라이언트와 서버 양측 네트워크 정보[송신자 IP, 송신자 port, 수신자 IP, 수신자 port] 4가지이다. 이 증빙이 있으면 클라이언트에서 서버로 데이터를 보낼수 있게 된다.&lt;/p&gt;

&lt;p&gt;송신자가 데이터를 보냈을 때 수신자측에서 소켓을 가지고 있지 않은 상태라면(소켓데이터가 유실되거나) 연결 리셋(TCP reset) 응답이 온다. 이때 송신자는 다시 3 way handshake을 진행해야한다. 그 뒤 양쪽에 소켓이 생성되면 데이터를 보낼수 있다.&lt;/p&gt;

&lt;p&gt;클라이언트와 서버간의 연결이 확보되면 아래 layer들에서 데이터에 여러가지 정보를 덧붙인다. &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP layer는 데이터 전송의 안정성 관련 정보,&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;IP layer는 목적지 ip까지 잘도착하는데에 필요한 정보,&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;마지막으로 Data link layer는 목적지 IP에서 서버가 작동하고 있는 구체적인 하드웨어 정보를 담당한다. 그리고 네트워크에서 움직일수 있는 형태의 데이터로의 변환까지 책임진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP/IP stack에 대해 아주 짧게 정리하고 넘어가보자. (디테일에 대해선 다른 좋은글들이 많다. &lt;a href=&quot;https://d2.naver.com/helloworld/47667&quot;&gt;네이버 D2 TCP/IP 네트워크 스택 이해하기&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application layer&lt;/h2&gt;
&lt;p&gt;우리가 쓰는 chrome 등 모든 프로그램/앱이 application이다. application layer에서는 클라이언트와 서버가 소통하기로 한 방식에 맞게 보내는 데이터를 맞춰주는 역할을 한다. http, ftp등이 있는데 이들 모두 커뮤티케이션하는 방식이 다르므로 개별 구조에 맞추는 작업이다. Node.js에서는 http library가 이 일을 해준다.&lt;/p&gt;

&lt;p&gt;데이터를 규약에 맞게 만들고 나면 위에서 얘기한 &lt;strong&gt;socket&lt;/strong&gt;으로 데이터를 보낸다. 소켓의 &lt;strong&gt;“write socket buffer”&lt;/strong&gt; 으로 보내게 되는데 이때 system call을 전송이 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp-layer&quot;&gt;TCP layer&lt;/h2&gt;
&lt;p&gt;write socket buffer에 데이터가 오게 되면 차례차례 필요한 데이터를 붙여준다. TCP layer는 데이터 전송의 안정성을 높여주는 것이 목적이라고 했다. 그래서 붙여주는 데이터들이 “순서 데이터”, “확인 응답 데이터”, “포트 번호”등이다.&lt;/p&gt;

&lt;h3 id=&quot;순서-데이터&quot;&gt;순서 데이터&lt;/h3&gt;
&lt;p&gt;보통 클라이언트 요청이 하나의 패킷으로 전달되지않는다. 여러개로 나뉘어서 보내지는데, 네트워크 상태에 따라 순서대로 보내지지 않을 때가 많다. 이럴 때 순서 데이터를 이용한다. 받는 곳(서버)에서 데이터를 순서대로 다시 조립할수 있게 해준다. 그리고 순서 데이터로 빠진 데이터가 있는지도 알수 있기때문에 만약에 누락된 데이터가 있다면 이를 이용해 클라이언트에 다시 요청하는 프로세스가 쉽게 이루어진다.&lt;/p&gt;

&lt;h3 id=&quot;포트-번호&quot;&gt;포트 번호&lt;/h3&gt;
&lt;p&gt;목적지 컴퓨터의 어떤 프로그램으로 가야하는지에 대한 정보이다. 소켓은 송신자 IP, 송신자 포트번호,수신자 IP, 수신자 포트번호 로 구성된다. 포트번호가 있어야 소켓에 전송가능하다.&lt;/p&gt;

&lt;h3 id=&quot;확인-응답-데이터&quot;&gt;확인 응답 데이터&lt;/h3&gt;
&lt;p&gt;수신측에서 데이터를 받았다고 송신측에 메시지를 보냄으로써 안정성을 확보한다. 확인 응답데이터에는 에러 체크 또한 포함된다. 이게 당연한 것 같지만, 보낸 ‘데이터를 받았음’을 응답해주지 않는 프로토콜(ex. UDP)도 많다. 그러므로 당연한 것 같아도 아주 특별한 기능이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ip-layer&quot;&gt;IP layer&lt;/h2&gt;
&lt;p&gt;TCP layer를 지나 IP 레이어로 오게된다. TCP에서 받은 데이터에 출발지/목적지 IP가 붙여진다. 인터넷 네트워크는 복잡하게 구성되어있기 때문에 여러 IP들을 거쳐서 목적지 IP로 도착하게 해주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;IP layer에는 목적지로 가기 위한 다음 IP를 알수 있는 &lt;strong&gt;Routing table&lt;/strong&gt;이 존재한다. 이를 이용하여 목적지 IP로 가기 위한 다음 환승역을 찾는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-link-layer&quot;&gt;Data link layer&lt;/h2&gt;
&lt;p&gt;이 부분은 대부분 물리적인 것과 관련돼있다. MAC 주소와 NIC가 핵심이다.&lt;/p&gt;

&lt;h3 id=&quot;mac-주소&quot;&gt;MAC 주소&lt;/h3&gt;
&lt;p&gt;우리가 이용하는 개별 컴퓨터는 MAC 주소라는게 있는데 이 값은 컴퓨터마다 유니크하다. 여러대의 컴퓨터는 같은 IP를 공유하게 되므로 IP만으로 목적지가 어디인지 정확히 알수 없다. 은마아파트 101동이라는 정보만으로 친구 집의 위치를 알수 없는 것처럼말이다. IP가 “은마아파트 101동”이라면 “1203호”는 MAC주소이다.&lt;/p&gt;

&lt;p&gt;MAC주소가 덧붙여진 뒤 &lt;strong&gt;NIC&lt;/strong&gt;로 전달한다. NIC에서는 데이터를 인터넷 네트워크 선에서 이동가능한 bit들로 변환한다. 그리고 최종적으로 인터넷선으로 전달한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;서버에서-데이터-도착한-뒤&quot;&gt;서버에서 데이터 도착한 뒤&lt;/h1&gt;
&lt;p&gt;TCP/IP 스택에서 붙여진 여러가지 데이터를 이용해서 목적지 서버에 데이터가 잘 도착했다. 도착한 곳은 서버의 NIC이다. NIC에 도착하면 제일 먼저 NIC Buffer에 임시로 데이터가 저장된다. 그리고 NIC에서 &lt;em&gt;Interrupt&lt;/em&gt;를 일으켜 운영체제에 새로운 데이터가 왔음을 알린다. 이 알림을 받은 TCP/IP 스택에서 데이터를 가져간다. 그리고 TCP/IP 작업을 거꾸로 수행한다. &lt;strong&gt;클라이언트에서는 여러 데이터들을 덧붙이는 방식으로 TCP/IP 스택이 작동했다면, 서버측에서는 그 데이터를 떼어내며 작동한다. 떼어낸 데이터들은 서버 프로그램에 도착하는데 이용된다.&lt;/strong&gt; 여러 작업을 마친 뒤 TCP layer에서 port번호까지 맞는지 확인됐다면 &lt;u&gt;TCP layer와 서버 프로그램의 연결지점인 Socket&lt;/u&gt;에 데이터를 보낸다. 소켓 파일에 저장되는 것이 아니라 소켓의 구조체중 하나인 &lt;strong&gt;Receive socket buffer&lt;/strong&gt;에 데이터가 쌓이게 된다.
Receive socket buffer에 쌓인 데이터는 이제 운영체제의 책임에서 벗어났다. 이제부터는 Node.js 서버가 행동을 할 차례이다. &lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Node.js 서버 뿐만 아니라 대부분의 프로그램은 &lt;strong&gt;TCP layer와 서버 프로그램의 연결지점인 socket&lt;/strong&gt;에 데이터가 임시로 저장된 뒤 개별 프로그램에서 데이터를 가져와 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;계층별로 정보가 덧붙여진 데이터를 부르는 명칭이 있다. &lt;br /&gt;TCP -&amp;gt; 세그먼트 / IP -&amp;gt; 패킷 / Data link -&amp;gt; 프레임 / NIC -&amp;gt; 비트&lt;br /&gt;
(관련된 글을 처음 읽는 사람도 있을 까봐 명칭을 쓰지않고 작성한 글이다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
프로그램이 데이터를 가져와 처리하는 방식은 다음글에서.&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jan 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//before-arriving-server-server-series-1</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//before-arriving-server-server-series-1</guid>
        
        <category>node.js</category>
        
        <category>TCP/IP</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>백엔드 동시성 - 1. Postgres 가시성</title>
        <description>&lt;p&gt;데이터베이스단에서 동시성 확보는 디비 자체적으로 해주는 것과 프로그래머가 직접 코드로 짜야하는 걸로 나뉜다. 그중 데이터베이스에서 제공해주는 부분을 알아본다.&lt;/p&gt;

&lt;p&gt;“1. 기본적인 잠금(shared/exclusive lock)”과 “2. Isolation level 구현(MVCC)” 이 두가지가 데이터베이스에서 이미 완성시켜둔 동시성 도구들이다. 이 둘의 조합으로 기본적인 동시성 제어를 구성한다.&lt;/p&gt;

&lt;h2 id=&quot;1-기본-잠금---shared-lock-exclusive-lock&quot;&gt;1. 기본 잠금 - Shared Lock, Exclusive Lock&lt;/h2&gt;
&lt;p&gt;모든 데이터베이스에서는 update, delete문이 실행되는 동안 해당 row를 잠궈버린다. 다른 쿼리중에서 update, delete문이 같은 row에 대해 실행하려한다면 이전 쿼리의 트랜잭션이 끝날때까지 기다려야한다. INSERT, UPDATE, DELETE문은 트랜잭션을 명시적으로 설정하지않아도 데이터베이스가 알아서 트랜잭션을 실행하고 작업이 완료되면 트랜잭션을 끝낸다. 반대로 기본적으로 아무것도 설정하지않은(트랜잭션 X, for update 설정 X) select문은 트랜잭션도, Lock도 이용하지않는다.&lt;/p&gt;

&lt;p&gt;여기서 쓰이는 잠금은 “Shared Lock”과 “Exclusive Lock”이다.&lt;/p&gt;

&lt;p&gt;Shared Lock: 내가 이 데이터 보고 있으니까 데이터 바꾸지마. 보기만 해. 근데 너도 같이 잠글수 있어(shared lock만)&lt;br /&gt;
Exclusive Lock: 내가 데이터 수정할거니까 보기만하고 수정하지마..&lt;/p&gt;

&lt;p&gt;두가지 잠금 모두 다른 트랜잭션에서 &lt;strong&gt;데이터 수정을 불가능&lt;/strong&gt;하게 만든다. &lt;strong&gt;둘의 차이점은 잠금을 걸었을 때 다른 잠금이 동시에 잠금을 걸수 있는지 없는지 여부다.&lt;/strong&gt; Exclusive Lock은 이름처럼 어떠한 락도 공존할수 없다. Shared Lock은 이름처럼 공존할수 있다. 다만 공존할수 있는 Lock은 Shared Lock뿐이다.
만약 트랜잭션A에서 row1에 Shared Lock을 건 상태라면 다른 트랜잭션에서도 row1에 Shared Lock을 걸수 있다. Shared Lock이 겹쳤을 때는 마지막 Shared Lock을 건 트랜잭션이 Lock을 풀면 해당 row의 shared Lock이 풀린다. Exclusive Lock은 동시에 다른 잠금을 걸수 없다.&lt;/p&gt;

&lt;h2 id=&quot;2-mvcc-multi-version-concurrency-control&quot;&gt;2. MVCC (Multi Version Concurrency Control)&lt;/h2&gt;
&lt;p&gt;MVCC는 대부분의 관계형 데이터베이스에서 통용되는 규칙인 “Isolation Level”을 구현한 것이다.&lt;/p&gt;

&lt;h3 id=&quot;mvcc의-논리적-기반&quot;&gt;MVCC의 논리적 기반&lt;/h3&gt;
&lt;p&gt;MVCC는 데이터베이스의 기본 저장방식인 &lt;strong&gt;COMMIT&lt;/strong&gt;을 이용한다. 데이터베이스는 데이터를 저장, 수정할 때 1차로 메모리에 저장한뒤에 트랜젝션이 COMMIT되면 DISK에 저장한다. (매커니즘에 따라 여러 커밋이 뭉쳐서 disk에 저장되기도 한다.)
커밋한 데이터만 읽어들일건지, 커밋하지않았지만 메모리에 저장된 데이터도 읽어들일건지에 따라 Isolation Level이 나뉜다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Committed&lt;/strong&gt;는 커밋된 데이터만 읽는다.&lt;br /&gt;
&lt;strong&gt;Repeatable Read&lt;/strong&gt;는 커밋되지 않은 데이터도 읽는다. 하지만 트랜잭션이 시작된 시점에도 존재했던 데이터만 읽는다.&lt;/p&gt;

&lt;p&gt;더 자세히 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;mvcc의-물리적-기반&quot;&gt;MVCC의 물리적 기반&lt;/h3&gt;
&lt;p&gt;Postgres MVCC는 Hint bit, commit log, snapshot, xmin, xmax 데이터를 이용하여 유효한 데이터를 판단한다.&lt;/p&gt;

&lt;h5 id=&quot;xmin-xmax&quot;&gt;xmin, xmax&lt;/h5&gt;
&lt;p&gt;먼저 xmin, xmax부터 알야아한다.(hint bit에서도 쓰이고 snapshot에서도 쓰이기 때문에) xmin, xmax는 모든 row가 가지고 있는 컬럼이다. 일반 컬럼이 아니고 시스템 컬럼이라서 명시적으로 검색하지않는 이상 기본적으로는 보이지않는다. &lt;br /&gt;
INSERT문이 실행되면서 row가 생성될 때 해당 트랜잭션의 ID를 해당 row의 xmin에 설정한다. xmin는 직관적으로 이해가 가지만 반면에 xmax는 조금 생소할수 있다. &lt;strong&gt;postgres는 기본적으로 update 작업을 할 때 기존 데이터를 변경하지 않는다.&lt;/strong&gt; 변경하는 대신에 기존 데이터의 xmax에 현재 트랜잭션 ID를 설정한다. 그리고 업데이드된 데이터를 가진 새로운 row를 생성한다. INSERT와 마찬가지로 xmin은 현재 트랜잭션 ID가 설정된다. DELETE는 기존 row의 xmax에 현재 트랜잭션 ID를 설정하고 끝이다. &lt;br /&gt;
정리하자면 특정 row에 xmax값이 존재한다면 그 값은 가장 최신의 값이 아니라고 생각할수 있다. 
여기서 짚고 넘어가야할 하나는 &lt;strong&gt;xmin 값이 있다는게 커밋됐다는 의미는 아니다.&lt;/strong&gt; row들이 커밋되기전에 임시로 저장되어있듯이 row들의 모든 컬럼들도(시스템컬럼 또한) 임시로 저장된 상태이다. &lt;strong&gt;커밋 여부는 커밋로그와 hint bit에서만 확실시 할수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;xmin, xmax를 대략 알았다면 다시 처음으로 돌아가자. 쿼리문에 대해 MVCC는 아래와 같은 순서로 작동한다.&lt;/p&gt;

&lt;h4 id=&quot;0-select문을-where절과-같이-실행&quot;&gt;0. SELECT문을 WHERE절과 같이 실행.&lt;/h4&gt;

&lt;h4 id=&quot;1-where-조건-확인&quot;&gt;1. WHERE 조건 확인&lt;/h4&gt;
&lt;p&gt;WHERE절의 조건대로 데이터를 필터링한다.&lt;/p&gt;

&lt;h3 id=&quot;21-커밋-여부-확인---hint-bit&quot;&gt;2.1 커밋 여부 확인 - Hint bit&lt;/h3&gt;
&lt;p&gt;WHERE 필터링된 row들의 header를 확인하여 hint bit를 확인하여 커밋 여부를 파악한다.&lt;/p&gt;

&lt;p&gt;모든 개별 row들은 개별 http 요청들이 헤더를 가지듯이 header를 가지고 있다. header안에 hint bit가 있는데 아래 4가지를 boolean값으로 가지고 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;XMIN_COMMITTED -- creating transaction is known committed
XMIN_ABORTED -- creating transaction is known aborted
XMAX_COMMITTED -- same, for the deleting transaction
XMAX_ABORTED -- ditto
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이름만 봐도 알수 있듯이 XMIN_COMMITTED가 true이면 커밋된 것을 의미하고 XMIN_ABORTED가 true라면 롤백된 트랜잭션을 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;22-커밋-여부-확인---commit-log&quot;&gt;2.2 커밋 여부 확인 - commit log&lt;/h4&gt;
&lt;p&gt;사실 hint bit는 commit log의 캐시버전이다. 그래서 hint bit부터 확인하고 hint bit가 없다면 커밋 로그를 확인하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;3-snapshot&quot;&gt;3. snapshot&lt;/h4&gt;
&lt;p&gt;(스냅샷은 내용이 좀 많다.)
데이터베이스 복구에 이용하는 스냅샷과는 이름만 같다. 하지만 특정시점의 데이터를 나타낸다는 것은 비슷하다. MVCC의 스냅샷은 트랜잭션이 실행되는 동안 “특정시점에 생성”되어 데이터 가시성을 판단하는 과정을 거친다. 먼저 스냅샷의 내용물은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedSnapshotData&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TransactionId&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 현재 활성화돼있는 트랜잭션 중 가장 작은 트랜잭션 ID&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TransactionId&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 현재 활성화돼있는 트랜잭션 중 가장 큰 트랜잭션 ID&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uint32&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;xcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;subxcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;suboverflowed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;takenDuringRecovery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CommandId&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;curcid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TimestampTz&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whenTaken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;XLogRecPtr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;lsn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedSnapshotData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// https://github.com/postgres/postgres/blob/06c418e163e913966e17cb2d3fb1c5f8a8d58308/src/backend/utils/time/snapmgr.c&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 이야기한 xmin, xmax를 가지고 있다. 위 단계에서 필터링된 row들은 모두 xmin, xmax 컬럼을 가지고 있는데(어떠한 모든 데이터들도 가지고 있다.) 이 컬럼들과 스냅샷의 xmin, xmax를 비교하여 어떤 row를 보여줄지 정한다.&lt;/p&gt;

&lt;p&gt;그리고 스냅샷을 언제 만드는지에 차이를 둬 Reqd Committed, Repeatable Read를 나눠 구현한다. (MVCC는 데이터베이스 Isolation을 구현한 것이니까)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Snapshot의 xmin, xmax 비교” + “스냅샷을 만드는 시점의 차이”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Repeatable Read&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Repeatable Read 레벨에서의 스냅샷 생성 시기는 트랜잭션 마다 단 한번이다. 트랜잭션이 시작할 때 스냅샷을 생성하고 한 트랜잭션 안에 있는 모든 쿼리가 같은 스냅샷을 이용하게 된다. 스냅샷에 존재하는 xmin값은 스냅샷 생성시기에 활성화되어 있던 모든 트랜잭션 중 가장 먼저 실행되고 있떤 값이다. 그렇기 때문에 스냅샷의 xid보다 큰 값의 xid를 가지고 있는 row는 아직 커밋되지않은 것으로 간주된다. 그리하여 결과에 포함되지않는다.&lt;/p&gt;

&lt;p&gt;그리고 제일 핵심으로는 Repeatable Read는 한 트랜잭션내에서는 같은 결과를 보여줘야하기때문에 최저활성 트랜잭션 ID보다 이후에 생성/수정된 데이터는 보여주지 않는 방식으로 구현한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Committed&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Read Committed는 스냅샷을 이용하지 않는다고 생각해도 된다. &lt;strong&gt;개별 쿼리가 실행되는 시점에 커밋된 데이터인지 아닌지만 판단하면 되기때문이다.&lt;/strong&gt; 같은 트랜잭션안의 두 쿼리가 실행될 때 첫 번째 쿼리가 실행된 후에 다른 트랜잭션에서 새로운 데이터를 만들고 커밋하면 첫번째 쿼리에서는 안보이던 데이터가 두번째 쿼리에서는 보이게된다.(같은 조건의 쿼리들이 같은 트랜잭션안에서 다른 값을 보여줄수 있다.) Read Committed는 커밋로그와 Hint bit만으로도 구현이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Serializable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Serialzable의 스냅샷 이용방식은 Repeatable Read와 거의 똑같다. 트랜잭신이 시작했을 때만 스냅샷을 생성하고 해당 트랜잭션동안 그 스냅샷을 이용한다.(Repeatable Read와 같이 스냅샷 이전에 커밋된 데이터만 보인다.) 한가지 다른점은 하나의 트랜잭션이 건드린 데이터는 해당 트랜잭션이 끝나기전까지 다른 트랜잭션이 못건드리게 한다. 건드리면 늦게 건드린 명령은 롤백된다. (SSI를 찾아보면 좋다.)&lt;/p&gt;

&lt;h4 id=&quot;4-완전-마지막-단계가-하나-있다&quot;&gt;4. 완전 마지막 단계가 하나 있다.&lt;/h4&gt;
&lt;p&gt;위 단계를 거치면서 필터링된 데이터들이 남게 된다. 그 데이터중에서는 여러개의 row가 사실은 하나의 데이터일때가 있다.(postgres에서는 Update/Delete시 기존 데이터를 지우는게 아니라 xmax에 transaction id를 설정하니깐) 그럴 때 하나의 값만을 보여주기 위해 xmax값이 존재하는 데이터는 보이지않고 xmin만 설정돼 있는 데이터를 보여주게 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Dec 2023 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//mvcc</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//mvcc</guid>
        
        <category>백엔드</category>
        
        <category>데이터베이스</category>
        
        <category>Hit Bits</category>
        
        <category>database</category>
        
        <category>MVCC</category>
        
        
      </item>
    
      <item>
        <title>Socket.io 무중단 배포</title>
        <description>&lt;p&gt;채팅 서버 무중단 배포 방식을 정리하고 가자.&lt;/p&gt;

&lt;p&gt;BlueGreen, Canary과 같은 배포 방식에 관련된 글이라기보다는 무중단 배포에 있어 채팅 서버의 어떤 점들을 유의해야하는지에 대한 글이겠다. (Socket.io를 기준으로)&lt;/p&gt;

&lt;p&gt;Socket 배포에 있어서 중요한 건 “client-server간의 관련 데이터 관리”, “client-server connection 관리”이 두가지가 되겠다.&lt;/p&gt;

&lt;h2 id=&quot;socketio-관련-데이터-관리&quot;&gt;socket.io 관련 데이터 관리.&lt;/h2&gt;
&lt;p&gt;socket.io에서는 실시간 통신을 위해 필요한 데이터들이 몇가지 있다. 보통 session이라고 한다.&lt;/p&gt;

&lt;p&gt;SocketId: 기본적으로 클라-서버가 연결됐을 때 만들어진다.
Namespaces: 소켓에서 구획을 나눠서 이용할수 있게 해주는 기준이다. 보통 기능에 따라 나눈다. (e.g. normal-chat, group-chat)
Rooms: namespace안에서 한번 더 구분되는 단위라고 생각하면 된다. (e.g. normal-chat(namespace)중에서 1번 room)
Event Handler: 특정 이벤트에 대한 행동&lt;/p&gt;

&lt;p&gt;socket.io에서는 session들을 &lt;strong&gt;adapter&lt;/strong&gt;라는 도구로 관리한다. 하나의 인스턴스에서 socket.io가 작동한다면 기본적으로 memory adapter로 관리된다. 인스턴스 개수가 두개가 될때부터는 데이터 동기화를 위해 외부 저장장치로 adapter를 설정해야한다. redis, db등 여러가지가 있고 redis가 주로 많이 쓰인다. 
socketId, namespace등이 adapter를 통해 실시간으로 동기화되어 데이터를 목적지 client들에게 전달할 수 있게된다.
실시간 동기화되는 데이터저장소가 있기때문에 업데이트시에도 기존 상태 데이터가 잘 보관될수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;connection-관리&quot;&gt;Connection 관리.&lt;/h2&gt;
&lt;p&gt;Socket.io로 연결된 클라이언트는 socketId를 받게 된다. 서버쪽에서는 socketId를 adapter에 저장해두어 커낵션 정보를 관리한다. socket.io 서버는 아래와 같은 형식으로 데이터들을 저장한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;sids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SocketId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 소켓ID와 room 매칭 데이터&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;sids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;socketId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socketId2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId3&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SocketId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// room과 소켓ID 매칭 데이터&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;roomId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socketId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socketId2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무중단 배포가 시작되고 한 인스턴스가 업데이트 된다면 해당 인스턴스와 연결된 클라이언트들은 socket 연결이 끊긴다. 그런데 Socket.io 자체에는 자동 재연결 기능이 구현되어있다. 연결이 끊긴다면 바로 재연결을 시도하고 재연결이 완료되면 새로운 socketId를 받게 된다.
(재연결 시도 할 때, 로드밸런서의 도움으로 지금 업데이트중인 인스턴스가 아니라 이용가능한/살아있는 다른 인스턴스와 연결이 된다.)&lt;/p&gt;

&lt;p&gt;이때 우리가 서버쪽에 추가적인 작업을 하나 셋팅해둬야한다. &lt;strong&gt;“reconnection” 이벤트가 발생했을 때 유저가 이용중이던 채팅방에 다시 join() 시켜주는 기능이 필요하다.&lt;/strong&gt;
우선 중앙 저장소에 현재 접속되어있는 채팅방-유저 데이터를 저장하고 있어야한다. 채팅방1: [유저1, 유저2, 유저3] 이런 데이터를 실시간으로 유지하고 있다면 reconnection 이벤트가 발생했을 때 해당 유저가 이용중이던 room에 바로 다시 join() 시켜줄수 있게 된다.
이렇게 된다면 &lt;strong&gt;&lt;em&gt;socket 서버에 다시 연결하는 시간 + 내가 이용중인 채팅방 정보 가져오는 시간 + 해당 채팅방으로 다시 join() 하는 시간 으로 중단 시간이 단축된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Jul 2023 00:00:00 -0500</pubDate>
        <link>http://0.0.0.0:4000//socketio-non-stop-deployment</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//socketio-non-stop-deployment</guid>
        
        <category>node.js</category>
        
        <category>Socket.io</category>
        
        
      </item>
    
      <item>
        <title>Nest.js 모듈 구조 관리 (Avoiding circular dependency)</title>
        <description>&lt;p&gt;어떤 아키텍쳐를 쓰던 DI(dependency injection)는 대부분 이용된다. Nest.js의 기본 구조도 그렇다.
그런데 DI로 개발하다보면 의존성이 꼬이는 일이 발생하는 경우가 있다. 대부분이  &lt;strong&gt;circular dependency&lt;/strong&gt;로 나타난다.
이 때 &lt;em&gt;lazy loading&lt;/em&gt;을 이용해서 circular dependency 발생 없이 개발할수도 있지만 상호의존은 최악의 구조이기 때문에 최대한 불가피한 경우에만 써야한다.&lt;/p&gt;

&lt;p&gt;내가 관리하는 프로젝트들에서 상호 의존을 피하기 위한 규칙들은 아래와 같다.&lt;/p&gt;

&lt;h2 id=&quot;1-테이블-마다-모듈을-만든다는-생각부터-버려야한다&quot;&gt;1. 테이블 마다 모듈을 만든다는 생각부터 버려야한다.&lt;/h2&gt;
&lt;p&gt;나 또한 개발 초기에는 대부분의 백엔드 강의가 CRUD 강의였기때문에 테이블과 거의 1대1 매칭이 됐다. 그렇게 배웠다보니 나도 실무에서 그렇게 해왔다. 하지만 어느 순간 상호 의존하는 상황이 발생했다.(지금도 꽤 발생한다..) 가장 큰 이유는 개별 모듈이 너무 커졌기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;종류에-따라-분리&quot;&gt;종류에 따라 분리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/writing-images/user-module.png&quot; alt=&quot;1&quot; /&gt;
User, Order, Product 이 3가지의 테이블을 가진 서비스를 생각해보자. 모듈을 테이블대로 3개만 만들어서 이용한다면 초기에는 괜찮았겠지만 서비스가 커질수록 기능이 아주 많아지면서 개별 모듈의 기능들 또한 많아진다(책임이 커진다).
예를 들면, User의 종류도 처음엔 한 종류였다. 그런데 한달뒤에 비로그인 유저가 주문할수 있는 기능도 생겨날수 있다. 혹은 유저 등급에 따라 기능이 분리될수도 있게 된다.(e.g. PaidUser, UnpaidUser).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“기능이 많다” 라는 건 “다른 모듈의 기능을 필요할(의존할) 확률이 높아진다”와 같은 말이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PaidUser, UnpaidUser, NonLoginedUser 처럼 여러개로 나눠 모듈을 관리한다면 &lt;strong&gt;PaidUser에서만 결제 정보에 대해 의존하면 된다.&lt;/strong&gt; UnpaidUser와 NonLoginedUser 모듈에서는 결제 정보를 의존하지 않아도 된다. 반대로 UnpaidUser에서만 필요한 모듈은 Unpaid모듈에서만 의존하고 다른 곳에서는 의존하지 않는다. &lt;strong&gt;정말 필요한 기능에서만 의존성을 주입하게 되는 구조가 성립된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하지만 한 뿌리에서 나온 모듈들이다보니 공통되는 기능들이 꽤나 존재하게 된다. 그럴 때는 User 모듈을 공통 기능/API 모듈로 사용한다.&lt;/strong&gt; 혹은 좀 더 명시적이고 싶다면 UserCore, UserShare 모듈로 이름 지어도 좋다.&lt;/p&gt;

&lt;h3 id=&quot;혼합된-형식으로-만들어-분리&quot;&gt;혼합된 형식으로 만들어 분리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/writing-images/order-and-user-module.png&quot; alt=&quot;1&quot; /&gt;
한뿌리에서 나온 모듈을 종류에 따라 분리하는 방법이 모듈 관리의 절반을 차지한다면, 나머지 절반은 &lt;strong&gt;&lt;em&gt;혼합된 형식&lt;/em&gt;&lt;/strong&gt;이 차지한다. User종류들과 Order이 합쳐진 UserOrder, NonUserOrder 모듈처럼 나뉠수 있다. &lt;u&gt;쇼핑몰에서 흔히 볼수 있는 비회원 구매 기능을 생각하면 좋다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;두가지 데이터를 혼합한 모듈을 만들면 모듈의 기능이 분리되서 관리가 쉬워진다. 나누지 않았다면 Order 모듈에서 모두 책임을 져야하니 말이다.&lt;/p&gt;

&lt;h2 id=&quot;2-방향-또한-중요하다&quot;&gt;2. 방향 또한 중요하다.&lt;/h2&gt;
&lt;p&gt;User, Order에서 둘의 관계는 User가 Order를 여러개 가진다. &lt;strong&gt;일대다(완벽히 일대다는아니지만)와 같은 관계에서는 ‘다’가 ‘일’을 의존하도록 해야한다.&lt;/strong&gt; 논리적으로 대부분이 그렇다. Order API를 개발할 때 User 정보를 가져올 확률이 높지 User API에서 Order 정보를 가져올 일은 그리 많지않다. 있을수 있지만 비율적으로 비교가 불가하다. 그러니 ‘다’ 방향에서 ‘일’을 의존해야한다. ‘일’에서 ‘다’를 의존하게 된다면 기존 구조가 불량할 확률이 높다.&lt;/p&gt;

&lt;h2 id=&quot;3-1-to-1은-보통-하나의-모듈에서-처리해도-되긴하는데&quot;&gt;3. 1 to 1은 보통 하나의 모듈에서 처리해도 되긴하는데..&lt;/h2&gt;
&lt;p&gt;이미 다들 그렇게 하시겠지만.. User, Profile이 있다면 User 모듈에서 Profile에 대한 모든 기능을 처리하면된다. 그런데 만약에 Profile 기능이 꽤나 많다면 UserProfile이란 혼합 모듈을 만들면 더 깔끔해진다.&lt;/p&gt;

&lt;p&gt;여기서 둘의 차이점을 생각해보고 지나가자. 
“1. Order모듈에서 Receipt모듈 처리” vs “2. 개별 모듈로 분리”&lt;/p&gt;

&lt;p&gt;1의 장점은 URL이 깔끔해진다. 
“GET order/:id/receipt” vs “GET receipt?orderId=123” 이렇게 비교하면 전자가 직관적이고 깔끔하다. 그러나 URL의 직관성도 중요하긴하지만, 백엔드 구조의 깔끔함이 우선임을 생각하면(추후에 확장가능성까지 생각한다면) 후자가 훨씬 좋은 선택지라고 할수 있다.&lt;/p&gt;

&lt;h2 id=&quot;4-작은-모듈을-유지해야-변경에-용이하다&quot;&gt;4. 작은 모듈을 유지해야 변경에 용이하다.&lt;/h2&gt;
&lt;p&gt;위 다른 이유들도 중요하지만 모든 것이 계획대로 되지만은 않는다. 바쁘다보면 실수하고 안바빠도 실수한다. 그러려면 변경이 쉬워야하는데 큰 모듈들로 구조가 유지된다면 구조를 잘못짰을 때 변경하기가 쉽지않다. 여러 모듈로 나뉜 상태라면 각 모듈마다 기능이 적을테니 의존성이 꼬였을 때 새로운 모듈로 이전하기가 쉬워진다.&lt;/p&gt;

&lt;h2 id=&quot;5-여러군데서-쓰이는-기능은-share-모듈로&quot;&gt;5. 여러군데서 쓰이는 기능은 Share 모듈로.&lt;/h2&gt;
&lt;p&gt;여러 코드베이스에서 Shared, Common 같은 폴더를 봤을 것이다. 이 모듈들은 최대한 다른 모듈을 의존하지않은 상태로 유지된다. 그리고 모든 다른 모듈들이 이 모듈을 의존하는 형태로 관리된다. 한군데 모듈에서만 쓰이는 기능이 아니라면 바로 이런 공통 모듈에 박아두면 Circular dependency가 발생할 확률이 줄어든다.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Jun 2023 00:00:00 -0500</pubDate>
        <link>http://0.0.0.0:4000//dependnecy-manage-on-nestjs</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//dependnecy-manage-on-nestjs</guid>
        
        <category>nest.js</category>
        
        <category>circular dependency</category>
        
        <category>module</category>
        
        
      </item>
    
      <item>
        <title>Join 알고리즘 대표적 3가지 특징/최적화</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/join-algorithms-1&quot;&gt;1. Join 알고리즘의 종류&lt;/a&gt; &lt;br /&gt;
&lt;u&gt;(현재글) 2. Join 알고리즘 최적화&lt;/u&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3가지-조인-비교&quot;&gt;3가지 조인 비교&lt;/h1&gt;

&lt;p&gt;3가지 조인 알고리즘이 어떤 상황에 선택되는지(유리한지) 알아보자.
일단은 시간복잡도부터 따져보면. Nested Loop은 O(N*M), Hash와 Sort-Merge는 O(N+M)이다.&lt;/p&gt;

&lt;p&gt;조인 알고리즘은 &lt;strong&gt;WHERE문으로 필터링된 데이터의 갯수&lt;/strong&gt;에 따라 첫번째로 갈린다.
WHERE문으로 필터링이 많이돼서 Join할 데이터가 적다면 Nested Loop 조인을 이용한다. WHERE문으로 필터링된 뒤에도 데이터가 많이 남아있다면 Hash 조인과 Merge 조인을 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;nested-loop&quot;&gt;Nested loop&lt;/h2&gt;

&lt;p&gt;Nested Loop Join은 보통 WHERE문으로 필터링된 데이터가 적을 때 이용된다. 이유는 단순하다. &lt;strong&gt;Nested Loop은 특별한 초기 프로세스가 없기 때문이다.&lt;/strong&gt; Hash 조인은 &lt;strong&gt;Hash 테이블을 만들어야하고&lt;/strong&gt;, Merge 조인은 조인하는 테이블들을 Join 키를 기준으로 &lt;strong&gt;정렬&lt;/strong&gt;해야한다. Nested Loop은 아무것도 없다. 그냥 하나하나 비교하는게 끝이다.
시간복잡도가 다른 알고리즘보다 높음에도 불구하고(O(N*M)) 다른 알고리즘과 다르게 초기 작업이 없기때문에 가볍게 진행될수 있다.
&lt;strong&gt;다만 데이터가 많아지면 시간복잡도의 성능 저하가 기초작업에 필요한 성능 저하보다 커지게된다.&lt;/strong&gt; 그렇게 되면 다른 조인 알고리즘을 선택하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;hash-vs-sort-merge&quot;&gt;Hash vs Sort Merge&lt;/h2&gt;
&lt;p&gt;이제 Hash 조인과 Sort Merge 조인 중 어떤 알고리즘이 선택되는지에 대해 알아보자. 아래 4가지를 핵심으로 데이터베이스 옵티마이저가 어떤게 좋은 쿼리 성능을 낼지 판단하게 된다.&lt;/p&gt;

&lt;h3 id=&quot;1-인덱스&quot;&gt;1. 인덱스&lt;/h3&gt;
&lt;p&gt;양쪽 테이블이 Join하는 필드에 인덱스가 설정돼있다면 Sort Merge Join이 유리하다. 이름부터 정렬이 붙어있는것만봐도 알수 있듯이 양쪽테이블을 정렬하는 것이 Sort Merge Join의 시작이다. 그런데 &lt;strong&gt;정렬을 진행할 조인키에 이미 인덱스가 설정되어있다면 이미 정렬이 돼있는 것이기때문에 정렬 과정이 생략된다.&lt;/strong&gt; 정렬 작업이 제일 큰 리소스를 소모하는 단계였기때문에 Hash Join보다 큰 성능을 낼수 있게 된다.
둘다 O(N+M)의 시간복잡도를 가졌는데 Sort Merge Join은 기초작업(정렬)이 사라진 반면 Hash Join은 여전히 기초 작업(해시 테이블을 만드는 작업)이 필요하다. 그러므로 성능상 우위에 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-데이터-분포&quot;&gt;2. 데이터 분포&lt;/h3&gt;
&lt;p&gt;테이블끼리 조인될 때 모두 one-to-one으로 하나씩 매칭돼서 조인되는 것이 아니라 ManyToOne, ManyToMany와 같이 몇몇 인기있는 행에만 여러 조인이 생길때가 많다. (학생과 강의 테이블이 있다고 하면 특정 인기 강의를 조인하는 학생 데이터가 훨씬 많다.) 이러한 상황에 해시테이블을 만들게 되면 같은 해시 테이블 키에 여러 데이터가 들어가버린다.(해시테이블의 값은 일반적으로 바구니(bucket) 형태이다. 여러개의 값이 들어갈수 있다는 의미.) 해시테이블에서는 key에 대해 값이 너무 여러개가 돼버리면 해시키로 값을 찾은 뒤에도 그 값들에서 또 Join key 비교를 해야한다. 이렇듯 해시충돌이 많이 발생해버리면 해시 테이블을 만들어 key로 빠르게 value를 찾으려는 의미가 사라져버린다.&lt;/p&gt;

&lt;h3 id=&quot;3-양쪽-테이블의-데이터-양&quot;&gt;3. 양쪽 테이블의 데이터 양&lt;/h3&gt;
&lt;p&gt;Hash Join은 양쪽 테이블 중 크기가 작은 것을 이용해 해시테이블을 만드는데 크기가 둘 다 크다면 메모리 이용율이 많아져 좋지 않다. 그리고 해시 데이터가 많아질수록 해시충돌할 확률이 커지므로 성능이 저하된다. 양쪽 테이블의 크기가 크다면 메모리 사용율이 적은 Sort Merge Join이 유리하다.&lt;/p&gt;

&lt;h3 id=&quot;4-이용가능한-메모리&quot;&gt;4. 이용가능한 메모리&lt;/h3&gt;
&lt;p&gt;위에서 계속해서 Hash Join은 메모리에 해시테이블을 만든다고 했다. 그러니 당연하게도 Sort Merge Join보다 메모리 이용이 커지니 메모리가 부족한 환경에서는 불리하다.&lt;/p&gt;

&lt;h3 id=&quot;5-join-key의-크기-복잡성&quot;&gt;5. Join key의 크기, 복잡성&lt;/h3&gt;
&lt;p&gt;Join에 이용되는 Key가 너무 길거나 복잡하면 비교 작업에 시간이 더 걸릴 수 있다. 정렬 또한 비교작업이기 때문에 Sort Merge Join에는 취약하다. 반면에 Hash는 key의 복잡성에 그리 큰 영향을 받지 않는다. 그리고 해시함수의 결과값은 인풋의 복잡성,길이에 아무 상관없이 고정된 길이로 변환한다. 그러므로 복잡한 Join key를 가지고 비교하는 과정이 덜한 Hash join이 다른 알고리즘에 비해 유리하다.&lt;/p&gt;

&lt;p&gt;위 5가지 +a로 데이터베이스 옵티마이저가 무엇이 좋을지 판단해서 쿼리를 실행하게 된다.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Jan 2023 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//join-algorithms-2</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//join-algorithms-2</guid>
        
        <category>database</category>
        
        <category>join</category>
        
        
      </item>
    
      <item>
        <title>Join 알고리즘 대표적 3가지</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;(현재글) 1. Join 알고리즘의 종류&lt;/u&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/join-algorithms-1&quot;&gt;2. Join 알고리즘 최적화&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
Join을 포함한 쿼리가 실행될 때 데이터베이스 프로세서는 지금 디비 상황에 맞는 join 알고리즘을 선택해야 한다. 대표적인 3가지를 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;nested-loop-join&quot;&gt;Nested Loop Join&lt;/h1&gt;
&lt;p&gt;이름 그대로 중첩 loop 방식으로 조건에 맞는 데이터를 찾는다. 중첩 for문이라고 생각하면 된다.
첫번째 테이블에서 데이터를 하나 선택하고 두번째 테이블을 선회하면서 둘의 조인키를 확인하며 조건이 맞는지 확인한다.
User와 School 테이블이 있고 서로가 userId로 조인된 상태라면 아래 처럼 작동한다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫번째 Loop&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;schools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두번째 Loop&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;schoolId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두 테이블의 데이터를 가져왔으니 조인 조건 확인.&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;pushToResultArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 조건이 맞다면 결과에 추가.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 복잡도가 n제곱이라서 성능상 좋지않은거냐고 할수 있다. 맞다. 그래서 많은 양의 데이터를 검색할때는 성능이 좋지않다.
그런데 대부분의 쿼리에는 &lt;strong&gt;where절&lt;/strong&gt;이 있기때문에 최대한 loop에 돌아가는 범위를 줄이게 된다. where로 데이터 범위를 줄일수 없다면 데이터베이스가 알아서 다른 join 알고리즘으로 변경하여 성능을 최적화한다.&lt;/p&gt;

&lt;h1 id=&quot;hash-join&quot;&gt;Hash Join&lt;/h1&gt;
&lt;p&gt;Hash Join은 두 테이블이 조인하는 특정 값을 이용한다. 둘이 같은 값을 가지고 있기 때문에(user, school이라면 user가 schoolId를 가지므로 같은 값을 가짐.) &lt;strong&gt;같은 해시 함수를 실행하면 같은 응답값이 나오는 걸 이용하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;먼저 해시 테이블을 만든다. 조인된 두 테이블 중 사이즈가 작은 테이블을 찾는다. 그리고 작은 사이즈의 테이블로 해시테이블을 만든다. &lt;strong&gt;해시 테이블&lt;/strong&gt;의 키는 조인에 이용되는 값을 해시 함수 실행시켜 얻은 값이다. &lt;strong&gt;해시 테이블의 값&lt;/strong&gt;은 해당 열이다. 해당 열의 일부분이 될수도 있고 전부가 될수도 있다. 혹은 해당 열의 메모리 주소값일수도 있다.(메모리 주소로 값을 저장하면 추후에 메모리 주소로 다시 접근하여 데이터를 얻어야하는 단점이 있다.)&lt;/p&gt;

&lt;p&gt;데이터가 아래와 같다면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/writing-images/usertable.png&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;/img/writing-images/schooltable.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 School테이블이 사이즈가 더 작기때문에 School 테이블을 이용하여 해시 테이블을 만든다. User와 School 테이블은 schoolId로 서로 조인하고 있기 때문에 School.id를 해시함수 실행시켜 키 값을 설정한다. 그리고 해시 테이블의 값으로는 해당 열 데이터의 일부를 저장한다. 예시에서는 school 데이터의 ID를 저장한다.&lt;/p&gt;

&lt;p&gt;‘aaa1’은 1을 해시함수 돌린 값, ‘aaa2’는 2를 해시함수 돌린값이라고 생각하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/writing-images/hashtable.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 나머지 테이블(크기가 좀더 큰 테이블: User)&lt;/strong&gt;에서 작업을 시작한다. User 테이블을 순회하여 School과의 조인을 나타내는 값을 해시 함수 실행시킨다. 해시 함수 실행 결과 값을 해시 테이블과 매칭해서 같은 값이 있으면 해당 테이블과 결합시킨다. 그리고 결과 목록에 추가한다. User 테이블에서 순회를 마치면 결과 목록이 완성된다.&lt;/p&gt;

&lt;p&gt;대략 코드로 표현하면 이렇다.&lt;/p&gt;
&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;findSmallerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Schools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;biggerTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Schools&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hashTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createHashTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eachRow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;biggerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;joinedTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;findMatchingDataFromOtherTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hashFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;eachRow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;joinKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pushToJoinResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;joinedTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eachRwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;merge-join&quot;&gt;Merge Join&lt;/h1&gt;

&lt;p&gt;Merge 조인은 조인되는 두 테이블을 각자 조인키 값을 기준으로 정렬시킨다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;scholl_Id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOOLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
위 값으로 Merge 조인을 한다면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;개별 테이블이 공유하는 조인키로 정렬된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래를 보면 USERS가 school_id로 정렬된 걸 확인할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(School id로 정렬된 두 테이블)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이제 두 테이블을 맨위 부터 비교하며 조인 키값이 같은 데이터들을 찾는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;첫번째-비교&quot;&gt;첫번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;같은 키로 정렬된 상태이므로 바로바로 같은 조인키 값을 가진 데이터들을 찾을수 있다. 
같은 포인터 위치의 데이터끼리 조인키를 비교한다. &lt;strong&gt;값이 같다면 둘의 데이터를 병합하여 결과 데이터에 추가한다.
그리고 두 테이블 모두 포인터를 다음번 데이터로 옮긴다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;두번째-비교&quot;&gt;두번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;두번째 비교에서도 바로 포인터에 있는 데이터들이 조인키가 같다. 결과 목록에 병합하여 추가한다.&lt;/p&gt;

&lt;h4 id=&quot;세번째-비교&quot;&gt;세번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;세번째에 와서야 포인터에있는 값들이 조인키가 맞지않다. 이럴 때는 조인키를 비교하여 작은 값을 가진쪽에서 포인터를 다음으로 옮긴다.&lt;/p&gt;

&lt;h4 id=&quot;네번째-비교&quot;&gt;네번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이번에도 포인터들의 조인값을 비교해봤지만 같지 않다. 그런데 이번에는 조인값이 작은 쪽에서 더이상 다음 값으로 옮길수가 없다. 이러면 더이상 매칭할 데이터가 없는 것이기 때문에 탐색 과정이 끝난다. 그리고 병합된 데이터를 리턴한다.&lt;/p&gt;

&lt;p&gt;이때 Join 방식에 따라(inner, left, right, full etc..) 매칭되지않은 데이터들에 대해 null을 한쪽 테이블 데이터는 null을 설정해서 결과값에 추가할지 두 테이블 데이터 모두 보여주지않을지 결정하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;다음 글에서는 이 3가지 알고리즘의 최적화에 대해 알아보자.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Jan 2023 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//join-algorithms-1</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//join-algorithms-1</guid>
        
        <category>database</category>
        
        <category>join</category>
        
        
      </item>
    
  </channel>
</rss>