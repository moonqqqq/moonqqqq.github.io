<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>김문규블로그</title>
    <description>Node.js 백엔드 개발자</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 10 Aug 2024 13:15:08 +0900</pubDate>
    <lastBuildDate>Sat, 10 Aug 2024 13:15:08 +0900</lastBuildDate>
    <generator>Jekyll v4.3.3</generator>
    
      <item>
        <title>서버가 데이터를 받기까지 [epoll] - 서버가 작동하는 흐름 2</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;1.서버가 데이터를 받기까지 [운영체제에서]&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;&lt;u&gt;(현재글) 2.서버가 데이터를 받기까지 [libuv - epoll]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt;
3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt;
4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이전 단계에서 데이터가 “receive socket buffer”에 도착했다. 이제 Node.js 서버가 데이터를 가져와서 처리해야한다. 데이터를 가져오는 일을 해주는 것이 libuv의 한가지 책임 중 하나이다. (가져오는 일이라고 하기보단 서버와 클라이언트간의 연결인 소켓들을 관리해주는 일)&lt;/p&gt;

&lt;p&gt;일단 서버로 향하는 모든 연결은 하나의 소켓으로 가는게 아니다. 여러 클라이언트와 연결되기때문에 연결되는 클라이언트 수만큼 소켓이 생기게 된다. 이렇게 되면 관리해야하는 socket이 꽤나 많아지는데. 이를 관리하는 매커니즘 종류에 따라 IO 성능의 차이가 있다. 고전적인 방법(select, poll)보다 libuv가 탁월히 좋다. (select, poll, libuv 비교는 글 마지막에..)&lt;/p&gt;

&lt;p&gt;socket에서 데이터를 가져오는 것은 libuv의 책임이라고 했다. libuv안에 존재하는 OS별 라이브러리를 이용하여 작동한다. linux는 epoll, windows는 kqueue가 있다. 우리의 서버는 대부분 리눅스에서 돌아가니 “epoll”을 중심으로 파악해보자.&lt;/p&gt;

&lt;p&gt;epoll은 3가지 함수가 핵심이다. &lt;strong&gt;“epoll_create()”, “epoll_ctl()”, “epoll_wait()”&lt;/strong&gt;”.&lt;/p&gt;

&lt;h3 id=&quot;epoll_create&quot;&gt;epoll_create()&lt;/h3&gt;
&lt;p&gt;epoll_create()는 두가지 자료구조를 만든다. &lt;u&gt;첫번째 자료구조는 &quot;연결된 전체 fd 목록&quot;을 가진다.(**Interest list**) 두번째 자료구조는 &quot;새로운 이벤트가 발생한 fd목록&quot;을 가진다.(**ready list**)&lt;/u&gt; node.js 서버가 실행됐을 때 epoll_create() 또한 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;epoll_ctl&quot;&gt;epoll_ctl()&lt;/h3&gt;
&lt;p&gt;새로운 연결이 들어오면 &lt;strong&gt;&lt;em&gt;epoll_ctl()&lt;/em&gt;&lt;/strong&gt; 함수를 이용해서 새로운 FD를 Interest list에 등록한다. 이 등록 과정에서 &lt;em&gt;어떤 작업에 대해 감지&lt;/em&gt;할건지도 명시해주어야 한다. 예를 들어, 새로운 연결이 들어왔을 때는 EPOLLIN 이벤트를 감지하도록 설정해둔다.&lt;/p&gt;

&lt;p&gt;이제 새로운 데이터를 받아오는 셋팅이 완료된 상태이다. 이제 Interest list에 등록된 FD에서 감지중인 이벤트 중 이벤트가 하나라도 발생한다면 ready list에 해당 FD가 추가된다. event_crl() 함수를 이용하여 이벤트 필터링 프로세스를 추가한 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;epoll_wait&quot;&gt;epoll_wait()&lt;/h3&gt;
&lt;p&gt;이제 마지막으로 epoll_wait() 함수가 실행되면 ready list에 있는 FD들을 event loop에 전달한다.&lt;/p&gt;

&lt;h4 id=&quot;epoll_wait-디테일&quot;&gt;epoll_wait() 디테일&lt;/h4&gt;
&lt;p&gt;epoll_create()와 epoll_ctl()은 운영체제단에서 알아서 실행하지만 epoll_wait()는 event loop(libuv)단에서 실행된다. event loop의 &lt;strong&gt;poll phase&lt;/strong&gt;에서 IO 관련된 이벤트들을 처리하는건 이미 알고있을것이다. 그러니 당연히 새로운 IO 또한 poll phase에서 책임진다.&lt;/p&gt;

&lt;p&gt;poll phase내에서 epoll_wait() 함수를 실행하여 새로운 IO가 발생한 fd목록을 가져온다. 하지만 ready list에 어떠한 fd도 존재하지 않는다면 새로운 IO가 생길때까지 기다린다.(그래서 이름에 “wait”이 붙어있다.) 다만 이 기다리는 조건은 상황에 따라 달라진다. 아래 event loop 코드(uv_run())을 보면 다른 phase들과 다르게 uv__io_poll() 함수만 두번째 인자로 timeout을 가지고 있는걸 알수 있다. 이 timeout을 통해 얼마동안 새로운 IO를 기다릴지를 정한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// core.c&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop_flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;can_sleep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv__queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pending_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv__queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idle_handles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__run_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uv__run_idle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uv__run_prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UV_RUN_ONCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can_sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UV_RUN_DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv__backend_timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__metrics_inc_loop_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__io_poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두번째 인자로 타입아웃 값 존재.&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;timeout이 정해지는 조건은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;timeout = 0: poll phase 이전 phase들에 실행할 작업이 있을 때. 기다리지 않고 바로 응답한다.&lt;/li&gt;
  &lt;li&gt;timeout &amp;gt; 0: 이전 phase들 중 timer에만 작업이 있을 때 제일 임박한 작업을 기준으로 timeout이 정해진다.&lt;/li&gt;
  &lt;li&gt;timeout &amp;lt; 0: 이전 phase들 중 어떠한 곳에서도 진행해야할 작업이 없을 때는 무기한 기다린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;왜-이전-phase들만-기준으로-잡는지&quot;&gt;왜 이전 phase들만 기준으로 잡는지?&lt;/h4&gt;
&lt;p&gt;Event loop은 작업 종류에 따라 phase 별로 분리해뒀다. 그리고 정해진 순서에 따라 반복되며 실행된다. &lt;strong&gt;이 순서 자체가 서버 기능의 우선순위와 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Timers - 프로그램이 계획 잡아둔 작업&lt;/li&gt;
  &lt;li&gt;Pending Callbacks - 이전 iteration에서 미뤄진 작업&lt;/li&gt;
  &lt;li&gt;Idle, prepare - node 시스템 내부 작업 처리&lt;/li&gt;
  &lt;li&gt;Poll - IO 처리&lt;/li&gt;
  &lt;li&gt;Check (setImmediate callbacks) - Poll phase 다음에 실행돼야할 작업&lt;/li&gt;
  &lt;li&gt;Close Callbacks - 마무리된 작업에 대한 정리 작업&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;poll-phase-이전&quot;&gt;poll phase 이전&lt;/h4&gt;
&lt;p&gt;1~4번은 한바퀴 전 iteration에서 발생한 IO를 처리하는 목적을 가지고 있다. 먼저 받은 IO부터 우선적으로 처리한뒤 새로운 IO를 받도록 설계되었기 때문에 새로운 IO를 받는 시간(timeout)을 0으로 설정해놓는다. timeout이 0보다 커서 기다리게된다면 이전 IO에 대한 작업이 그만큼 멈춰지게 되기때문이다.&lt;/p&gt;

&lt;h4 id=&quot;poll-phase-이후&quot;&gt;poll phase 이후&lt;/h4&gt;
&lt;p&gt;반면에 “5.check phase”는 setImmediate 콜백들을 처리한다. 그런데 이 setImmediate 자체가 poll phase 바로 뒤에 실행되도록 설계된 함수다. 만들어진 이유가 그러니 당연히 epoll_wait() timeout의 조건에 들어가지 않는다. (setImmediate라는 이름 자체가 잘못지어진게 아닌가 싶다. 처음엔 Immediate인데 왜 poll 뒤에 작동하는지 납득이 안됐다.)&lt;/p&gt;

&lt;p&gt;“6.close phase”는 완료된 작업의 뒷작업이기 때문에 굳이 빨리 처리할 필요가 없다. 그러니 이 또한 timeout에 조건에 들어가지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리가 만드는 서버라는 것 자체가 Input을 받아 처리하는 Output을 전달해주는 것이기 때문에 Input을 받는 전략을 잘짜야한다. Input받는 작업을 계속 실행해주는 것은 당연히 다른 작업을 못하게 되므로 불가하다. 반면 받은 input을 처리하는데 시간을 많이 쏟고 새로운 input을 받는 시간이 적다면 이것 또한 문제다. input받는 시간과 받은 input을 처리하는 시간이 적절히 균형을 이루어야한다. Node.js에서는 이 &lt;strong&gt;timeout&lt;/strong&gt;을 통해 균형을 맞춘다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;epoll_wait-으로-받아온-데이터는&quot;&gt;epoll_wait() 으로 받아온 데이터는.&lt;/h2&gt;
&lt;p&gt;epoll_wait()으로 새로운 IO를 가진 fd목록을 가져왔다. 이 목록을 순회하면서 콜백을 실행시킨다. 이 콜백은 epoll_ctl()를 실행시킬 때 같이 등록해놓은 콜백이다. 데이터를 읽어오거나 에러를 처리하는 콜백이 실행된다.
Node.js에서 socket.on(‘data’, callback); 처럼 실행된다고 보면 간단하다.
&lt;strong&gt;&lt;em&gt;주의해야 할 점은 이 콜백들은 poll phase의 queue에 들어가거나 나오는 작업없이 epoll_wait()에서 응답받자마자 바로 실행된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 libuv에서 받아온 데이터가 http request로 변화할 차례다. 이건 다음글에서 이야기하자.&lt;/p&gt;

&lt;h3 id=&quot;selectpoll-vs-epoll&quot;&gt;Select/Poll VS Epoll&lt;/h3&gt;
&lt;p&gt;끝내기 전에 고전적인 방식(select, poll)과 epoll의 차이점을 간단히 정리해보고 가자.
select, poll의 방식은 서버가 정기적인 시간마다 서버와 연결된 socket들에 변화가 있는지 하나하나 확인한다. socket이 10000개라면 정기적인 시간마다 10000개를 확인하는 것이다. 반면에 epoll은 소켓들을 관리하는 자료구조를 따로 만들고. 소켓에 들어오는 이벤트들을 검사한다. libuv에 전달해줘야하는 이벤트인지 아닌지. 맞다면 관리 자료구조에 해당 fd를 적어둔다. 그리고 정기적으로 서버가 새로운 이벤트에 대해 요청하면 그 데이터만 전달한다. 다른 검사 과정은 없다. 이러니 획기적으로 fd 검사 횟수가 줄어들수 밖에 없다. 처음엔 소켓을 관리하는 데이터를 만들고. 모든 이벤트를 필터링하는 것도 부하가 들지 않을까 생각했지만 필터링 하나 넣는것이 그렇게 큰 부하가 드는 일이 아니라서 월등히 성능이 좋아질수 밖에 없다는 걸 받아들였다.&lt;/p&gt;

&lt;p&gt;필터링 과정이 부하가 되지는 않을까 생각해봤지만 매번 모든 fd를 확인해서 까보는 것에 비하면 비교할수 없을 정도로 부하가 작다.&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Jan 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//from-the-libuv-server-series-2</link>
        <guid isPermaLink="true">http://localhost:4000//from-the-libuv-server-series-2</guid>
        
        <category>node.js</category>
        
        <category>TCP/IP</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>API 서버가 데이터를 받기까지 (운영체제에서) - 서버가 작동하는 흐름 1</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;&lt;u&gt;(현재글) 1.서버가 데이터를 받기까지 [운영체제에서]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;2.서버가 데이터를 받기까지 [libuv]&lt;/a&gt; &lt;br /&gt;
3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt;
4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;api-서버가-데이터를-받기까지&quot;&gt;API 서버가 데이터를 받기까지.&lt;/h1&gt;
&lt;p&gt;우리가 만든 Node.js 서버가 데이터를 받기위해선 포트 번호(ex. 3000, 8080)와 바인딩되어야한다. 그래야만 운영체제가 node.js 서버 프로그램이 어디 있는지 알수있고 데이터를 보낼수 있다.
이제 포트와 연결된 상태로 서버가 &lt;strong&gt;실행&lt;/strong&gt;중이라면 서버에서는 데이터를 받을 준비가 됐다.&lt;/p&gt;

&lt;p&gt;송신자측을 이야기해보자.
송신자(클라이언트)는 데이터를 보내기전에 서버와 연결을 만들어야한다. 이때 TCP 연결이 필요하다. TCP 연결은 3 way handeshake로 만들어진다. &lt;strong&gt;3 way handshake가 완료되면 클라이언트와 서버에 socket이 생긴다.&lt;/strong&gt; 이 소켓(socket)이라는 건 connection이 가능하다는 증빙이라고 생각하면 된다. 소켓의 내용물는 클라이언트와 서버 양측 네트워크 정보[송신자 IP, 송신자 port, 수신자 IP, 수신자 port] 4가지이다. 이 증빙이 있으면 클라이언트에서 서버로 데이터를 보낼수 있게 된다.&lt;/p&gt;

&lt;p&gt;송신자가 데이터를 보냈을 때 수신자측에서 소켓을 가지고 있지 않은 상태라면(소켓데이터가 유실되거나) 연결 리셋(TCP reset) 응답이 온다. 이때 송신자는 다시 3 way handshake을 진행해야한다. 그 뒤 양쪽에 소켓이 생성되면 데이터를 보낼수 있다.&lt;/p&gt;

&lt;p&gt;클라이언트와 서버간의 연결이 확보되면 아래 layer들에서 데이터에 여러가지 정보를 덧붙인다. &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP layer는 데이터 전송의 안정성 관련 정보,&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;IP layer는 목적지 ip까지 잘도착하는데에 필요한 정보,&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;마지막으로 Data link layer는 목적지 IP에서 서버가 작동하고 있는 구체적인 하드웨어 정보를 담당한다. 그리고 네트워크에서 움직일수 있는 형태의 데이터로의 변환까지 책임진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP/IP stack에 대해 아주 짧게 정리하고 넘어가보자. (디테일에 대해선 다른 좋은글들이 많다. &lt;a href=&quot;https://d2.naver.com/helloworld/47667&quot;&gt;네이버 D2 TCP/IP 네트워크 스택 이해하기&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application layer&lt;/h2&gt;
&lt;p&gt;우리가 쓰는 chrome 등 모든 프로그램/앱이 application이다. application layer에서는 클라이언트와 서버가 소통하기로 한 방식에 맞게 보내는 데이터를 맞춰주는 역할을 한다. http, ftp등이 있는데 이들 모두 커뮤티케이션하는 방식이 다르므로 개별 구조에 맞추는 작업이다. Node.js에서는 http library가 이 일을 해준다.&lt;/p&gt;

&lt;p&gt;데이터를 규약에 맞게 만들고 나면 위에서 얘기한 &lt;strong&gt;socket&lt;/strong&gt;으로 데이터를 보낸다. 소켓의 &lt;strong&gt;“write socket buffer”&lt;/strong&gt; 으로 보내게 되는데 이때 system call을 전송이 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp-layer&quot;&gt;TCP layer&lt;/h2&gt;
&lt;p&gt;write socket buffer에 데이터가 오게 되면 차례차례 필요한 데이터를 붙여준다. TCP layer는 데이터 전송의 안정성을 높여주는 것이 목적이라고 했다. 그래서 붙여주는 데이터들이 “순서 데이터”, “확인 응답 데이터”, “포트 번호”등이다.&lt;/p&gt;

&lt;h3 id=&quot;순서-데이터&quot;&gt;순서 데이터&lt;/h3&gt;
&lt;p&gt;보통 클라이언트 요청이 하나의 패킷으로 전달되지않는다. 여러개로 나뉘어서 보내지는데, 네트워크 상태에 따라 순서대로 보내지지 않을 때가 많다. 이럴 때 순서 데이터를 이용한다. 받는 곳(서버)에서 데이터를 순서대로 다시 조립할수 있게 해준다. 그리고 순서 데이터로 빠진 데이터가 있는지도 알수 있기때문에 만약에 누락된 데이터가 있다면 이를 이용해 클라이언트에 다시 요청하는 프로세스가 쉽게 이루어진다.&lt;/p&gt;

&lt;h3 id=&quot;포트-번호&quot;&gt;포트 번호&lt;/h3&gt;
&lt;p&gt;목적지 컴퓨터의 어떤 프로그램으로 가야하는지에 대한 정보이다. 소켓은 송신자 IP, 송신자 포트번호,수신자 IP, 수신자 포트번호 로 구성된다. 포트번호가 있어야 소켓에 전송가능하다.&lt;/p&gt;

&lt;h3 id=&quot;확인-응답-데이터&quot;&gt;확인 응답 데이터&lt;/h3&gt;
&lt;p&gt;수신측에서 데이터를 받았다고 송신측에 메시지를 보냄으로써 안정성을 확보한다. 확인 응답데이터에는 에러 체크 또한 포함된다. 이게 당연한 것 같지만, 보낸 ‘데이터를 받았음’을 응답해주지 않는 프로토콜(ex. UDP)도 많다. 그러므로 당연한 것 같아도 아주 특별한 기능이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ip-layer&quot;&gt;IP layer&lt;/h2&gt;
&lt;p&gt;TCP layer를 지나 IP 레이어로 오게된다. TCP에서 받은 데이터에 출발지/목적지 IP가 붙여진다. 인터넷 네트워크는 복잡하게 구성되어있기 때문에 여러 IP들을 거쳐서 목적지 IP로 도착하게 해주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;IP layer에는 목적지로 가기 위한 다음 IP를 알수 있는 &lt;strong&gt;Routing table&lt;/strong&gt;이 존재한다. 이를 이용하여 목적지 IP로 가기 위한 다음 환승역을 찾는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-link-layer&quot;&gt;Data link layer&lt;/h2&gt;
&lt;p&gt;이 부분은 대부분 물리적인 것과 관련돼있다. MAC 주소와 NIC가 핵심이다.&lt;/p&gt;

&lt;h3 id=&quot;mac-주소&quot;&gt;MAC 주소&lt;/h3&gt;
&lt;p&gt;우리가 이용하는 개별 컴퓨터는 MAC 주소라는게 있는데 이 값은 컴퓨터마다 유니크하다. 여러대의 컴퓨터는 같은 IP를 공유하게 되므로 IP만으로 목적지가 어디인지 정확히 알수 없다. 은마아파트 101동이라는 정보만으로 친구 집의 위치를 알수 없는 것처럼말이다. IP가 “은마아파트 101동”이라면 “1203호”는 MAC주소이다.&lt;/p&gt;

&lt;p&gt;MAC주소가 덧붙여진 뒤 &lt;strong&gt;NIC&lt;/strong&gt;로 전달한다. NIC에서는 데이터를 인터넷 네트워크 선에서 이동가능한 bit들로 변환한다. 그리고 최종적으로 인터넷선으로 전달한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;서버에서-데이터-도착한-뒤&quot;&gt;서버에서 데이터 도착한 뒤&lt;/h1&gt;
&lt;p&gt;TCP/IP 스택에서 붙여진 여러가지 데이터를 이용해서 목적지 서버에 데이터가 잘 도착했다. 도착한 곳은 서버의 NIC이다. NIC에 도착하면 제일 먼저 NIC Buffer에 임시로 데이터가 저장된다. 그리고 NIC에서 &lt;em&gt;Interrupt&lt;/em&gt;를 일으켜 운영체제에 새로운 데이터가 왔음을 알린다. 이 알림을 받은 TCP/IP 스택에서 데이터를 가져간다. 그리고 TCP/IP 작업을 거꾸로 수행한다. &lt;strong&gt;클라이언트에서는 여러 데이터들을 덧붙이는 방식으로 TCP/IP 스택이 작동했다면, 서버측에서는 그 데이터를 떼어내며 작동한다. 떼어낸 데이터들은 서버 프로그램에 도착하는데 이용된다.&lt;/strong&gt; 여러 작업을 마친 뒤 TCP layer에서 port번호까지 맞는지 확인됐다면 &lt;u&gt;TCP layer와 서버 프로그램의 연결지점인 Socket&lt;/u&gt;에 데이터를 보낸다. 소켓 파일에 저장되는 것이 아니라 소켓의 구조체중 하나인 &lt;strong&gt;Receive socket buffer&lt;/strong&gt;에 데이터가 쌓이게 된다.
Receive socket buffer에 쌓인 데이터는 이제 운영체제의 책임에서 벗어났다. 이제부터는 Node.js 서버가 행동을 할 차례이다. &lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Node.js 서버 뿐만 아니라 대부분의 프로그램은 &lt;strong&gt;TCP layer와 서버 프로그램의 연결지점인 socket&lt;/strong&gt;에 데이터가 임시로 저장된 뒤 개별 프로그램에서 데이터를 가져와 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;계층별로 정보가 덧붙여진 데이터를 부르는 명칭이 있다. &lt;br /&gt;TCP -&amp;gt; 세그먼트 / IP -&amp;gt; 패킷 / Data link -&amp;gt; 프레임 / NIC -&amp;gt; 비트&lt;br /&gt;
(관련된 글을 처음 읽는 사람도 있을 까봐 명칭을 쓰지않고 작성한 글이다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
프로그램이 데이터를 가져와 처리하는 방식은 다음글에서.&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jan 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//before-arriving-server-server-series-1</link>
        <guid isPermaLink="true">http://localhost:4000//before-arriving-server-server-series-1</guid>
        
        <category>node.js</category>
        
        <category>TCP/IP</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>Socket.io 무중단 배포</title>
        <description>&lt;p&gt;채팅 서버 무중단 배포 방식을 정리하고 가자.&lt;/p&gt;

&lt;p&gt;BlueGreen, Canary과 같은 배포 방식에 관련된 글이라기보다는 무중단 배포에 있어 채팅 서버의 어떤 점들을 유의해야하는지에 대한 글이겠다. (Socket.io를 기준으로)&lt;/p&gt;

&lt;p&gt;Socket 배포에 있어서 중요한 건 “client-server간의 관련 데이터 관리”, “client-server connection 관리”이 두가지가 되겠다.&lt;/p&gt;

&lt;h2 id=&quot;socketio-관련-데이터-관리&quot;&gt;socket.io 관련 데이터 관리.&lt;/h2&gt;
&lt;p&gt;socket.io에서는 실시간 통신을 위해 필요한 데이터들이 몇가지 있다. 보통 session이라고 한다.&lt;/p&gt;

&lt;p&gt;SocketId: 기본적으로 클라-서버가 연결됐을 때 만들어진다.
Namespaces: 소켓에서 구획을 나눠서 이용할수 있게 해주는 기준이다. 보통 기능에 따라 나눈다. (e.g. normal-chat, group-chat)
Rooms: namespace안에서 한번 더 구분되는 단위라고 생각하면 된다. (e.g. normal-chat(namespace)중에서 1번 room)
Event Handler: 특정 이벤트에 대한 행동&lt;/p&gt;

&lt;p&gt;socket.io에서는 session들을 &lt;strong&gt;adapter&lt;/strong&gt;라는 도구로 관리한다. 하나의 인스턴스에서 socket.io가 작동한다면 기본적으로 memory adapter로 관리된다. 인스턴스 개수가 두개가 될때부터는 데이터 동기화를 위해 외부 저장장치로 adapter를 설정해야한다. redis, db등 여러가지가 있고 redis가 주로 많이 쓰인다. 
socketId, namespace등이 adapter를 통해 실시간으로 동기화되어 데이터를 목적지 client들에게 전달할 수 있게된다.
실시간 동기화되는 데이터저장소가 있기때문에 업데이트시에도 기존 상태 데이터가 잘 보관될수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;connection-관리&quot;&gt;Connection 관리.&lt;/h2&gt;
&lt;p&gt;Socket.io로 연결된 클라이언트는 socketId를 받게 된다. 서버쪽에서는 socketId를 adapter에 저장해두어 커낵션 정보를 관리한다. socket.io 서버는 아래와 같은 형식으로 데이터들을 저장한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;sids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SocketId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 소켓ID와 room 매칭 데이터&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;sids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;socketId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socketId2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId3&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SocketId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// room과 소켓ID 매칭 데이터&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;roomId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socketId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socketId2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무중단 배포가 시작되고 한 인스턴스가 업데이트 된다면 해당 인스턴스와 연결된 클라이언트들은 socket 연결이 끊긴다. 그런데 Socket.io 자체에는 자동 재연결 기능이 구현되어있다. 연결이 끊긴다면 바로 재연결을 시도하고 재연결이 완료되면 새로운 socketId를 받게 된다.
(재연결 시도 할 때, 로드밸런서의 도움으로 지금 업데이트중인 인스턴스가 아니라 이용가능한/살아있는 다른 인스턴스와 연결이 된다.)&lt;/p&gt;

&lt;p&gt;이때 우리가 서버쪽에 추가적인 작업을 하나 셋팅해둬야한다. &lt;strong&gt;“reconnection” 이벤트가 발생했을 때 유저가 이용중이던 채팅방에 다시 join() 시켜주는 기능이 필요하다.&lt;/strong&gt;
우선 중앙 저장소에 현재 접속되어있는 채팅방-유저 데이터를 저장하고 있어야한다. 채팅방1: [유저1, 유저2, 유저3] 이런 데이터를 실시간으로 유지하고 있다면 reconnection 이벤트가 발생했을 때 해당 유저가 이용중이던 room에 바로 다시 join() 시켜줄수 있게 된다.
이렇게 된다면 &lt;strong&gt;&lt;em&gt;socket 서버에 다시 연결하는 시간 + 내가 이용중인 채팅방 정보 가져오는 시간 + 해당 채팅방으로 다시 join() 하는 시간 으로 중단 시간이 단축된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//socketio-non-stop-deployment</link>
        <guid isPermaLink="true">http://localhost:4000//socketio-non-stop-deployment</guid>
        
        <category>node.js</category>
        
        <category>Socket.io</category>
        
        
      </item>
    
      <item>
        <title>Nest.js 모듈 구조 관리 (Avoiding circular dependency)</title>
        <description>&lt;p&gt;어떤 아키텍쳐를 쓰던 DI(dependency injection)는 대부분 이용된다. Nest.js의 기본 구조도 그렇다.
그런데 DI로 개발하다보면 의존성이 꼬이는 일이 발생하는 경우가 있다. 대부분이  &lt;strong&gt;circular dependency&lt;/strong&gt;로 나타난다.
이 때 &lt;em&gt;lazy loading&lt;/em&gt;을 이용해서 circular dependency 발생 없이 개발할수도 있지만 상호의존은 최악의 구조이기 때문에 최대한 불가피한 경우에만 써야한다.&lt;/p&gt;

&lt;p&gt;내가 관리하는 프로젝트들에서 상호 의존을 피하기 위한 규칙들은 아래와 같다.&lt;/p&gt;

&lt;h2 id=&quot;1-테이블-마다-모듈을-만든다는-생각부터-버려야한다&quot;&gt;1. 테이블 마다 모듈을 만든다는 생각부터 버려야한다.&lt;/h2&gt;
&lt;p&gt;나 또한 개발 초기에는 대부분의 백엔드 강의가 CRUD 강의였기때문에 테이블과 거의 1대1 매칭이 됐다. 그렇게 배웠다보니 나도 실무에서 그렇게 해왔다. 하지만 어느 순간 상호 의존하는 상황이 발생했다.(지금도 꽤 발생한다..) 가장 큰 이유는 개별 모듈이 너무 커졌기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;종류에-따라-분리&quot;&gt;종류에 따라 분리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/writing-images/user-module.png&quot; alt=&quot;1&quot; /&gt;
User, Order, Product 이 3가지의 테이블을 가진 서비스를 생각해보자. 모듈을 테이블대로 3개만 만들어서 이용한다면 초기에는 괜찮았겠지만 서비스가 커질수록 기능이 아주 많아지면서 개별 모듈의 기능들 또한 많아진다(책임이 커진다).
예를 들면, User의 종류도 처음엔 한 종류였다. 그런데 한달뒤에 비로그인 유저가 주문할수 있는 기능도 생겨날수 있다. 혹은 유저 등급에 따라 기능이 분리될수도 있게 된다.(e.g. PaidUser, UnpaidUser).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“기능이 많다” 라는 건 “다른 모듈의 기능을 필요할(의존할) 확률이 높아진다”와 같은 말이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PaidUser, UnpaidUser, NonLoginedUser 처럼 여러개로 나눠 모듈을 관리한다면 &lt;strong&gt;PaidUser에서만 결제 정보에 대해 의존하면 된다.&lt;/strong&gt; UnpaidUser와 NonLoginedUser 모듈에서는 결제 정보를 의존하지 않아도 된다. 반대로 UnpaidUser에서만 필요한 모듈은 Unpaid모듈에서만 의존하고 다른 곳에서는 의존하지 않는다. &lt;strong&gt;정말 필요한 기능에서만 의존성을 주입하게 되는 구조가 성립된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하지만 한 뿌리에서 나온 모듈들이다보니 공통되는 기능들이 꽤나 존재하게 된다. 그럴 때는 User 모듈을 공통 기능/API 모듈로 사용한다.&lt;/strong&gt; 혹은 좀 더 명시적이고 싶다면 UserCore, UserShare 모듈로 이름 지어도 좋다.&lt;/p&gt;

&lt;h3 id=&quot;혼합된-형식으로-만들어-분리&quot;&gt;혼합된 형식으로 만들어 분리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/writing-images/order-and-user-module.png&quot; alt=&quot;1&quot; /&gt;
한뿌리에서 나온 모듈을 종류에 따라 분리하는 방법이 모듈 관리의 절반을 차지한다면, 나머지 절반은 &lt;strong&gt;&lt;em&gt;혼합된 형식&lt;/em&gt;&lt;/strong&gt;이 차지한다. User종류들과 Order이 합쳐진 UserOrder, NonUserOrder 모듈처럼 나뉠수 있다. &lt;u&gt;쇼핑몰에서 흔히 볼수 있는 비회원 구매 기능을 생각하면 좋다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;두가지 데이터를 혼합한 모듈을 만들면 모듈의 기능이 분리되서 관리가 쉬워진다. 나누지 않았다면 Order 모듈에서 모두 책임을 져야하니 말이다.&lt;/p&gt;

&lt;h2 id=&quot;2-방향-또한-중요하다&quot;&gt;2. 방향 또한 중요하다.&lt;/h2&gt;
&lt;p&gt;User, Order에서 둘의 관계는 User가 Order를 여러개 가진다. &lt;strong&gt;일대다(완벽히 일대다는아니지만)와 같은 관계에서는 ‘다’가 ‘일’을 의존하도록 해야한다.&lt;/strong&gt; 논리적으로 대부분이 그렇다. Order API를 개발할 때 User 정보를 가져올 확률이 높지 User API에서 Order 정보를 가져올 일은 그리 많지않다. 있을수 있지만 비율적으로 비교가 불가하다. 그러니 ‘다’ 방향에서 ‘일’을 의존해야한다. ‘일’에서 ‘다’를 의존하게 된다면 기존 구조가 불량할 확률이 높다.&lt;/p&gt;

&lt;h2 id=&quot;3-1-to-1은-보통-하나의-모듈에서-처리해도-되긴하는데&quot;&gt;3. 1 to 1은 보통 하나의 모듈에서 처리해도 되긴하는데..&lt;/h2&gt;
&lt;p&gt;이미 다들 그렇게 하시겠지만.. User, Profile이 있다면 User 모듈에서 Profile에 대한 모든 기능을 처리하면된다. 그런데 만약에 Profile 기능이 꽤나 많다면 UserProfile이란 혼합 모듈을 만들면 더 깔끔해진다.&lt;/p&gt;

&lt;p&gt;여기서 둘의 차이점을 생각해보고 지나가자. 
“1. Order모듈에서 Receipt모듈 처리” vs “2. 개별 모듈로 분리”&lt;/p&gt;

&lt;p&gt;1의 장점은 URL이 깔끔해진다. 
“GET order/:id/receipt” vs “GET receipt?orderId=123” 이렇게 비교하면 전자가 직관적이고 깔끔하다. 그러나 URL의 직관성도 중요하긴하지만, 백엔드 구조의 깔끔함이 우선임을 생각하면(추후에 확장가능성까지 생각한다면) 후자가 훨씬 좋은 선택지라고 할수 있다.&lt;/p&gt;

&lt;h2 id=&quot;4-작은-모듈을-유지해야-변경에-용이하다&quot;&gt;4. 작은 모듈을 유지해야 변경에 용이하다.&lt;/h2&gt;
&lt;p&gt;위 다른 이유들도 중요하지만 모든 것이 계획대로 되지만은 않는다. 바쁘다보면 실수하고 안바빠도 실수한다. 그러려면 변경이 쉬워야하는데 큰 모듈들로 구조가 유지된다면 구조를 잘못짰을 때 변경하기가 쉽지않다. 여러 모듈로 나뉜 상태라면 각 모듈마다 기능이 적을테니 의존성이 꼬였을 때 새로운 모듈로 이전하기가 쉬워진다.&lt;/p&gt;

&lt;h2 id=&quot;5-여러군데서-쓰이는-기능은-share-모듈로&quot;&gt;5. 여러군데서 쓰이는 기능은 Share 모듈로.&lt;/h2&gt;
&lt;p&gt;여러 코드베이스에서 Shared, Common 같은 폴더를 봤을 것이다. 이 모듈들은 최대한 다른 모듈을 의존하지않은 상태로 유지된다. 그리고 모든 다른 모듈들이 이 모듈을 의존하는 형태로 관리된다. 한군데 모듈에서만 쓰이는 기능이 아니라면 바로 이런 공통 모듈에 박아두면 Circular dependency가 발생할 확률이 줄어든다.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Jun 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//dependnecy-manage-on-nestjs</link>
        <guid isPermaLink="true">http://localhost:4000//dependnecy-manage-on-nestjs</guid>
        
        <category>nest.js</category>
        
        <category>circular dependency</category>
        
        <category>module</category>
        
        
      </item>
    
      <item>
        <title>Join 알고리즘 대표적 3가지</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;(현재글) 1. Join 알고리즘의 종류&lt;/u&gt; &lt;br /&gt;
&lt;a href=&quot;&quot;&gt;2. Join 알고리즘 최적화&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
Join을 포함한 쿼리가 실행될 때 데이터베이스 프로세서는 지금 디비 상황에 맞는 join 알고리즘을 선택해야 한다. 대표적인 3가지를 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;nested-loop-join&quot;&gt;Nested Loop Join&lt;/h1&gt;
&lt;p&gt;이름 그대로 중첩 loop 방식으로 조건에 맞는 데이터를 찾는다. 중첩 for문이라고 생각하면 된다.
첫번째 테이블에서 데이터를 하나 선택하고 두번째 테이블을 선회하면서 둘의 조인키를 확인하며 조건이 맞는지 확인한다.
User와 School 테이블이 있고 서로가 userId로 조인된 상태라면 아래 처럼 작동한다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫번째 Loop&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;schools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두번째 Loop&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;schoolId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두 테이블의 데이터를 가져왔으니 조인 조건 확인.&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;pushToResultArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 조건이 맞다면 결과에 추가.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 복잡도가 n제곱이라서 성능상 좋지않은거냐고 할수 있다. 맞다. 그래서 많은 양의 데이터를 검색할때는 성능이 좋지않다.
그런데 대부분의 쿼리에는 &lt;strong&gt;where절&lt;/strong&gt;이 있기때문에 최대한 loop에 돌아가는 범위를 줄이게 된다. where로 데이터 범위를 줄일수 없다면 데이터베이스가 알아서 다른 join 알고리즘으로 변경하여 성능을 최적화한다.&lt;/p&gt;

&lt;h1 id=&quot;hash-join&quot;&gt;Hash Join&lt;/h1&gt;
&lt;p&gt;Hash Join은 두 테이블이 조인하는 특정 값을 이용한다. 둘이 같은 값을 가지고 있기 때문에(user, school이라면 user가 schoolId를 가지므로 같은 값을 가짐.) &lt;strong&gt;같은 해시 함수를 실행하면 같은 응답값이 나오는 걸 이용하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;먼저 해시 테이블을 만든다. 조인된 두 테이블 중 사이즈가 작은 테이블을 찾는다. 그리고 작은 사이즈의 테이블로 해시테이블을 만든다. &lt;strong&gt;해시 테이블&lt;/strong&gt;의 키는 조인에 이용되는 값을 해시 함수 실행시켜 얻은 값이다. &lt;strong&gt;해시 테이블의 값&lt;/strong&gt;은 해당 열이다. 해당 열의 일부분이 될수도 있고 전부가 될수도 있다. 혹은 해당 열의 메모리 주소값일수도 있다.(메모리 주소로 값을 저장하면 추후에 메모리 주소로 다시 접근하여 데이터를 얻어야하는 단점이 있다.)&lt;/p&gt;

&lt;p&gt;데이터가 아래와 같다면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/writing-images/usertable.png&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;/img/writing-images/schooltable.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 School테이블이 사이즈가 더 작기때문에 School 테이블을 이용하여 해시 테이블을 만든다. User와 School 테이블은 schoolId로 서로 조인하고 있기 때문에 School.id를 해시함수 실행시켜 키 값을 설정한다. 그리고 해시 테이블의 값으로는 해당 열 데이터의 일부를 저장한다. 예시에서는 school 데이터의 ID를 저장한다.&lt;/p&gt;

&lt;p&gt;‘aaa1’은 1을 해시함수 돌린 값, ‘aaa2’는 2를 해시함수 돌린값이라고 생각하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/writing-images/hashtable.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 나머지 테이블(크기가 좀더 큰 테이블: User)&lt;/strong&gt;에서 작업을 시작한다. User 테이블을 순회하여 School과의 조인을 나타내는 값을 해시 함수 실행시킨다. 해시 함수 실행 결과 값을 해시 테이블과 매칭해서 같은 값이 있으면 해당 테이블과 결합시킨다. 그리고 결과 목록에 추가한다. User 테이블에서 순회를 마치면 결과 목록이 완성된다.&lt;/p&gt;

&lt;p&gt;대략 코드로 표현하면 이렇다.&lt;/p&gt;
&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findSmallerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Schools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;biggerTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Schools&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hashTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createHashTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eachRow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;biggerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;joinedTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findMatchingDataFromOtherTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hashFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;eachRow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;joinKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pushToJoinResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;joinedTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eachRwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;merge-join&quot;&gt;Merge Join&lt;/h1&gt;

&lt;p&gt;Merge 조인은 조인되는 두 테이블을 각자 조인키 값을 기준으로 정렬시킨다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;scholl_Id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOOLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
위 값으로 Merge 조인을 한다면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;개별 테이블이 공유하는 조인키로 정렬된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(School id로 정렬된 두 테이블)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이제 두 테이블을 맨위 부터 비교하며 조인 키값이 같은 데이터들을 찾는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;첫번째-비교&quot;&gt;첫번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;같은 키로 정렬된 상태이므로 바로바로 같은 조인키 값을 가진 데이터들을 찾을수 있다. 
같은 포인터 위치의 데이터끼리 조인키를 비교한다. &lt;strong&gt;값이 같다면 둘의 데이터를 병합하여 결과 데이터에 추가한다.
그리고 두 테이블 모두 포인터를 다음번 데이터로 옮긴다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;두번째-비교&quot;&gt;두번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;두번째 비교에서도 바로 포인터에 있는 데이터들이 조인키가 같다. 결과 목록에 병합하여 추가한다.&lt;/p&gt;

&lt;h4 id=&quot;세번째-비교&quot;&gt;세번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;세번째에 와서야 포인터에있는 값들이 조인키가 맞지않다. 이럴 때는 조인키를 비교하여 작은 값을 가진쪽에서 포인터를 다음으로 옮긴다.&lt;/p&gt;

&lt;h4 id=&quot;네번째-비교&quot;&gt;네번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이번에도 포인터들의 조인값을 비교해봤지만 같지 않다. 그런데 이번에는 조인값이 작은 쪽에서 더이상 다음 값으로 옮길수가 없다. 이러면 더이상 매칭할 데이터가 없는 것이기 때문에 탐색 과정이 끝난다. 그리고 병합된 데이터를 리턴한다.&lt;/p&gt;

&lt;p&gt;이때 Join 방식에 따라(inner, left, right, full etc..) 매칭되지않은 데이터들에 대해 null을 한쪽 테이블 데이터는 null을 설정해서 결과값에 추가할지 두 테이블 데이터 모두 보여주지않을지 결정하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;다음 글에서는 이 3가지 알고리즘의 최적화에 대해 알아보자.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//join-algorithms-1</link>
        <guid isPermaLink="true">http://localhost:4000//join-algorithms-1</guid>
        
        <category>database</category>
        
        <category>join</category>
        
        
      </item>
    
  </channel>
</rss>