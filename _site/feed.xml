<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>김문규블로그</title>
    <description>Node.js 백엔드 개발자</description>
    <link>http://0.0.0.0:4000//</link>
    <atom:link href="http://0.0.0.0:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 08 Feb 2026 06:44:09 -0600</pubDate>
    <lastBuildDate>Sun, 08 Feb 2026 06:44:09 -0600</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>Node.js의 스트림 배압 처리 고도화 (Observable의 한계점)</title>
        <description>&lt;p&gt;LLM 응답 스트리밍 서버가 OOM(Out of memory)으로인해 꺼져버리는 현상이 간간히 로그에 찍혀있었다.&lt;/p&gt;

&lt;p&gt;기존 서버는 llm 응답값을 sse로 스트리밍해주는 서버다. 단순히 @Sse 데코레이터에 Observable을 리턴하는 형식으로 구현되어있다. 단순화하면 아래 구조로 표현할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream API server –(subscribe)–&amp;gt; Redis pubsub  &amp;lt;–(push)– llm 워커에서 llm 응답값 전달&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;@Sse가 알아서 헤더 설정도 해주고 응답값도 잘 정리해주고, 커넥션 에러도 잘 처리해주기때문에 초기 구현에는 좋았지만. 트레픽이 몰릴때는 백프레셔 문제가 발생했다. 아래 코드는 아주 간단한 @Sse 구현 코드다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Sse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;chat-message/:messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;getLlmAnswer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MessageEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;redisService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`llm:answer:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 서버에 동시에 많은 트레픽을 쏴버리면 아래처럼 OOM 에러가 발생하면서 서버가 종료된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 46MB
server-1  | Heap Total: 59MB
server-1  | RSS: 114MB
server-1  | External: 5MB

~

server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 155MB
server-1  | Heap Total: 199MB
server-1  | RSS: 246MB
server-1  | External: 17MB
server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 165MB
server-1  | Heap Total: 210MB
server-1  | RSS: 244MB
server-1  | External: 5MB
server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 174MB
server-1  | Heap Total: 222MB
server-1  | RSS: 261MB
server-1  | External: 13MB
server-1  | ======================
server-1  | === Memory Monitor ===
server-1  | Heap Used: 183MB
server-1  | Heap Total: 234MB
server-1  | RSS: 278MB
server-1  | External: 21MB
server-1  | ======================
server-1 exited with code 137  # OOM 발생
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;몰린 트레픽으로 인해 메모리 사용량이 확 올라 서버가 갑자기 꺼져버린다.&lt;/p&gt;

&lt;h2 id=&quot;observable의-한계&quot;&gt;Observable의 한계&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Observable은 백프래셔가 제대로 구현돼있지 않다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Node.js Stream은 메모리를 적당량만 꾸준히 이용하는 선에서 안정성을 유지한다고 알고있었는데 Observable 내부를 까보니 단순히 Observable에 데이터 소스를 연결해두면 &lt;strong&gt;Observable 내부 버퍼에 데이터가 계속 쌓이는 문제&lt;/strong&gt;가 발생한다. 클라이언트가 데이터를 정상적으로 받고 있다면 문제가 되지않지만 클라이언트에서 데이터를 받을수 없는 상황이 오면 데이터를 멈추지않고 메모리에 계속 쌓는 상황이었다. 그러다 OOM 이 발생했다.&lt;/p&gt;

&lt;p&gt;Observable이 작동하는 방식을 파악해보니 아래와 같았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;데이터소스 -&amp;gt; observer.next() -&amp;gt; [RxJS 전용(concatMap) 버퍼] -&amp;gt; [WritableStream 버퍼] -&amp;gt; [Socket 버퍼]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Node.js 자체적으로&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;TCP socket 버퍼에 데이터가 꽉차면 writableStream 버퍼에서 데이터를 안보내게 되고.&lt;/li&gt;
  &lt;li&gt;WritableStream 버퍼에 데이터가 꽉차면 RxJS 전용 버퍼에서 데이터를 안보내게 된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;하지만 RxJS의 버퍼는 꽉찼는지 아닌지에 대한 기준이 존재하지않았다.&lt;/strong&gt; 
그러다보니 당연하게도 Out Of Memory가 발생할수 밖에 없었다. 클라이언트쪽이던 서버쪽이던 네트워크문제가 생긴다면 어쩔수 없는거였다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;push-매커니즘이기때문에&quot;&gt;Push 매커니즘이기때문에&lt;/h3&gt;
&lt;p&gt;이 문제의 근본 원인은 Observable, RxJS 자체가 Push 매커니즘이기때문이라고 한다.
Observable 다큐먼트를 들어가면 뜬금없게도 pull, push 에 대한 내용부터 나온다. &lt;a href=&quot;https://rxjs.dev/guide/observable&quot;&gt;Observable Document&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Push&lt;/strong&gt; 매커니즘은 데이터 송신측에서 보낼 수 있다면 어떠한 상황도 상관없이 그냥 보내는 구조.
&lt;strong&gt;Pull&lt;/strong&gt; 매커니즘은 데이터 수신측에서 받고 싶을때만 받도록 하는 구조다. (Kafka가 그래서 안정성이 좋다고들한다)&lt;/p&gt;

&lt;h3 id=&quot;왜-push-매커니즘을-사용하는지&quot;&gt;왜 push 매커니즘을 사용하는지&lt;/h3&gt;
&lt;p&gt;근본적으로 메모리에 대해선 불안전한 편인데 왜 Push 매커니즘을 쓰는지 찾아보니 RxJS자체가 프론트엔드 이벤트 처리용으로 만들어졌기때문이라고 한다. 이벤트가 언제 발생한지 알수 없기때문에 pull 방식은 불가능하다. JS가 callback을 이용하는 이유와 거의 같지않나 생각이 든다.&lt;/p&gt;

&lt;h2 id=&quot;해결책&quot;&gt;해결책&lt;/h2&gt;
&lt;p&gt;해결책은 간단하다. &lt;strong&gt;@Sse() 데코레이터 + Observable 조합&lt;/strong&gt;에서 &lt;strong&gt;Response 객체&lt;/strong&gt;를 직접 이용하는 방식으로 전환하면 된다. 그리고 데이터소스 또한 &lt;strong&gt;Pull&lt;/strong&gt; 방식의 도구로 변경해야한다. (Redis PubSub은 push 방식이기때문에 Pull 방식인 Redis Stream으로 전환했다.)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;제일 중요한점은 Response객체를 이용해서 클라이언트의 상태를 파악하는 것이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;res.write()는 응답값으로 더 데이터를 받을수 있는지 아닌지 여부를 리턴해준다.&lt;/strong&gt;
이값이 true일 때만 데이터를 계속 받아와서 전달할지 말지 코드를 짜면 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pull 방식으로 전환&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Redis Pubsub에서 Redis Stream으로 변경했기때문에 특정 시점부터 데이터를 받아올수 있다.(XREAD).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;그리고 “drain” 이벤트 구독&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;클라이언트가 데이터를 받을수 없는 상태라면 res.write() 가 false를 응답하기때문에 송신프로세스를 멈추고 대기해야한다. 그리고 drain 이벤트가 발행하면 그때 다시 보내면 된다.
drain(배수라는 뜻) 물이 빠졌으니 데이터를 다시 보내라는 신호다.&lt;/p&gt;

&lt;p&gt;아래는 변환된 샘플 코드다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// pseudo code&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;chat-message/:messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getLlmAnswer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// @Sse 를 안쓰기 때문에 직접 다 설정해야함.&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Content-Type&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;text/event-stream&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Cache-Control&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;no-cache&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;keep-alive&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;X-Accel-Buffering&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flushHeaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;streamKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`llm:answer:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;messageId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lastId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;disconnect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;redisService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;streamKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lastId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;lastId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canWrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`data: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;\n\n`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// 백프레셔: 버퍼 가득 차면 &quot;drain&quot; 대기&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;canWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;drain&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;writableEnded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;res.write(), ‘drain’ 이벤트만으로도 부하를 조절할수 있는 구조가 됐다.&lt;/p&gt;

&lt;p&gt;동일한 테스트를 실행하면 동일한 요청수에 OOM 이 발생하지않는다. 물론 요청수가 늘어나면 하드웨어가 제한돼어있으니 메모리 문제가 발생하지만 이건 하드웨어 수평확장으로 진행하면 된다.&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Feb 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//sse-and-observable-limitation-on-memory</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//sse-and-observable-limitation-on-memory</guid>
        
        <category>Nest.js</category>
        
        <category>Stream</category>
        
        <category>Observable</category>
        
        <category>RxJS</category>
        
        
      </item>
    
      <item>
        <title>서버가 데이터를 받기까지 [epoll] - 서버가 작동하는 흐름 2</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;1.서버가 데이터를 받기까지 [운영체제에서]&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;&lt;u&gt;(현재글) 2.서버가 데이터를 받기까지 [libuv - epoll]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt;
3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt;
4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이전 단계에서 데이터가 “receive socket buffer”에 도착했다. 이제 Node.js 서버가 데이터를 가져와서 처리해야한다. 데이터를 가져오는 일을 해주는 것이 libuv의 한가지 책임 중 하나이다. (가져오는 일이라고 하기보단 서버와 클라이언트간의 연결인 소켓들을 관리해주는 일)&lt;/p&gt;

&lt;p&gt;일단 서버로 향하는 모든 연결은 하나의 소켓으로 가는게 아니다. 여러 클라이언트와 연결되기때문에 연결되는 클라이언트 수만큼 소켓이 생기게 된다. 이렇게 되면 관리해야하는 socket이 꽤나 많아지는데. 이를 관리하는 매커니즘 종류에 따라 IO 성능의 차이가 있다. 고전적인 방법(select, poll)보다 libuv가 탁월히 좋다. (select, poll, libuv 비교는 글 마지막에..)&lt;/p&gt;

&lt;p&gt;socket에서 데이터를 가져오는 것은 libuv의 책임이라고 했다. libuv안에 존재하는 OS별 라이브러리를 이용하여 작동한다. linux는 epoll, windows는 kqueue가 있다. 우리의 서버는 대부분 리눅스에서 돌아가니 “epoll”을 중심으로 파악해보자.&lt;/p&gt;

&lt;p&gt;epoll은 3가지 함수가 핵심이다. &lt;strong&gt;“epoll_create()”, “epoll_ctl()”, “epoll_wait()”&lt;/strong&gt;”.&lt;/p&gt;

&lt;h3 id=&quot;epoll_create&quot;&gt;epoll_create()&lt;/h3&gt;
&lt;p&gt;epoll_create()는 두가지 자료구조를 만든다. &lt;u&gt;첫번째 자료구조는 &quot;연결된 전체 fd 목록&quot;을 가진다.(**Interest list**) 두번째 자료구조는 &quot;새로운 이벤트가 발생한 fd목록&quot;을 가진다.(**ready list**)&lt;/u&gt; node.js 서버가 실행됐을 때 epoll_create() 또한 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;epoll_ctl&quot;&gt;epoll_ctl()&lt;/h3&gt;
&lt;p&gt;새로운 연결이 들어오면 &lt;strong&gt;&lt;em&gt;epoll_ctl()&lt;/em&gt;&lt;/strong&gt; 함수를 이용해서 새로운 FD를 Interest list에 등록한다. 이 등록 과정에서 &lt;em&gt;어떤 작업에 대해 감지&lt;/em&gt;할건지도 명시해주어야 한다. 예를 들어, 새로운 연결이 들어왔을 때는 EPOLLIN 이벤트를 감지하도록 설정해둔다.&lt;/p&gt;

&lt;p&gt;이제 새로운 데이터를 받아오는 셋팅이 완료된 상태이다. 이제 Interest list에 등록된 FD에서 감지중인 이벤트 중 이벤트가 하나라도 발생한다면 ready list에 해당 FD가 추가된다. event_crl() 함수를 이용하여 이벤트 필터링 프로세스를 추가한 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;epoll_wait&quot;&gt;epoll_wait()&lt;/h3&gt;
&lt;p&gt;이제 마지막으로 epoll_wait() 함수가 실행되면 ready list에 있는 FD들을 event loop에 전달한다.&lt;/p&gt;

&lt;h4 id=&quot;epoll_wait-디테일&quot;&gt;epoll_wait() 디테일&lt;/h4&gt;
&lt;p&gt;epoll_create()와 epoll_ctl()은 운영체제단에서 알아서 실행하지만 epoll_wait()는 event loop(libuv)단에서 실행된다. event loop의 &lt;strong&gt;poll phase&lt;/strong&gt;에서 IO 관련된 이벤트들을 처리하는건 이미 알고있을것이다. 그러니 당연히 새로운 IO 또한 poll phase에서 책임진다.&lt;/p&gt;

&lt;p&gt;poll phase내에서 epoll_wait() 함수를 실행하여 새로운 IO가 발생한 fd목록을 가져온다. 하지만 ready list에 어떠한 fd도 존재하지 않는다면 새로운 IO가 생길때까지 기다린다.(그래서 이름에 “wait”이 붙어있다.) 다만 이 기다리는 조건은 상황에 따라 달라진다. 아래 event loop 코드(uv_run())을 보면 다른 phase들과 다르게 uv__io_poll() 함수만 두번째 인자로 timeout을 가지고 있는걸 알수 있다. 이 timeout을 통해 얼마동안 새로운 IO를 기다릴지를 정한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// core.c&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop_flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;can_sleep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv__queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pending_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv__queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idle_handles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__run_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uv__run_idle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uv__run_prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UV_RUN_ONCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can_sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UV_RUN_DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv__backend_timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__metrics_inc_loop_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;uv__io_poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두번째 인자로 타입아웃 값 존재.&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;timeout이 정해지는 조건은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;timeout = 0: poll phase 이전 phase들에 실행할 작업이 있을 때. 기다리지 않고 바로 응답한다.&lt;/li&gt;
  &lt;li&gt;timeout &amp;gt; 0: 이전 phase들 중 timer에만 작업이 있을 때 제일 임박한 작업을 기준으로 timeout이 정해진다.&lt;/li&gt;
  &lt;li&gt;timeout &amp;lt; 0: 이전 phase들 중 어떠한 곳에서도 진행해야할 작업이 없을 때는 무기한 기다린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;왜-이전-phase들만-기준으로-잡는지&quot;&gt;왜 이전 phase들만 기준으로 잡는지?&lt;/h4&gt;
&lt;p&gt;Event loop은 작업 종류에 따라 phase 별로 분리해뒀다. 그리고 정해진 순서에 따라 반복되며 실행된다. &lt;strong&gt;이 순서 자체가 서버 기능의 우선순위와 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Timers - 프로그램이 계획 잡아둔 작업&lt;/li&gt;
  &lt;li&gt;Pending Callbacks - 이전 iteration에서 미뤄진 작업&lt;/li&gt;
  &lt;li&gt;Idle, prepare - node 시스템 내부 작업 처리&lt;/li&gt;
  &lt;li&gt;Poll - IO 처리&lt;/li&gt;
  &lt;li&gt;Check (setImmediate callbacks) - Poll phase 다음에 실행돼야할 작업&lt;/li&gt;
  &lt;li&gt;Close Callbacks - 마무리된 작업에 대한 정리 작업&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;poll-phase-이전&quot;&gt;poll phase 이전&lt;/h4&gt;
&lt;p&gt;1~4번은 한바퀴 전 iteration에서 발생한 IO를 처리하는 목적을 가지고 있다. 먼저 받은 IO부터 우선적으로 처리한뒤 새로운 IO를 받도록 설계되었기 때문에 새로운 IO를 받는 시간(timeout)을 0으로 설정해놓는다. timeout이 0보다 커서 기다리게된다면 이전 IO에 대한 작업이 그만큼 멈춰지게 되기때문이다.&lt;/p&gt;

&lt;h4 id=&quot;poll-phase-이후&quot;&gt;poll phase 이후&lt;/h4&gt;
&lt;p&gt;반면에 “5.check phase”는 setImmediate 콜백들을 처리한다. 그런데 이 setImmediate 자체가 poll phase 바로 뒤에 실행되도록 설계된 함수다. 만들어진 이유가 그러니 당연히 epoll_wait() timeout의 조건에 들어가지 않는다. (setImmediate라는 이름 자체가 잘못지어진게 아닌가 싶다. 처음엔 Immediate인데 왜 poll 뒤에 작동하는지 납득이 안됐다.)&lt;/p&gt;

&lt;p&gt;“6.close phase”는 완료된 작업의 뒷작업이기 때문에 굳이 빨리 처리할 필요가 없다. 그러니 이 또한 timeout에 조건에 들어가지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리가 만드는 서버라는 것 자체가 Input을 받아 처리하는 Output을 전달해주는 것이기 때문에 Input을 받는 전략을 잘짜야한다. Input받는 작업을 계속 실행해주는 것은 당연히 다른 작업을 못하게 되므로 불가하다. 반면 받은 input을 처리하는데 시간을 많이 쏟고 새로운 input을 받는 시간이 적다면 이것 또한 문제다. input받는 시간과 받은 input을 처리하는 시간이 적절히 균형을 이루어야한다. Node.js에서는 이 &lt;strong&gt;timeout&lt;/strong&gt;을 통해 균형을 맞춘다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;epoll_wait-으로-받아온-데이터는&quot;&gt;epoll_wait() 으로 받아온 데이터는.&lt;/h2&gt;
&lt;p&gt;epoll_wait()으로 새로운 IO를 가진 fd목록을 가져왔다. 이 목록을 순회하면서 콜백을 실행시킨다. 이 콜백은 epoll_ctl()를 실행시킬 때 같이 등록해놓은 콜백이다. 데이터를 읽어오거나 에러를 처리하는 콜백이 실행된다.
Node.js에서 socket.on(‘data’, callback); 처럼 실행된다고 보면 간단하다.
&lt;strong&gt;&lt;em&gt;주의해야 할 점은 이 콜백들은 poll phase의 queue에 들어가거나 나오는 작업없이 epoll_wait()에서 응답받자마자 바로 실행된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 libuv에서 받아온 데이터가 http request로 변화할 차례다. 이건 다음글에서 이야기하자.&lt;/p&gt;

&lt;h3 id=&quot;selectpoll-vs-epoll&quot;&gt;Select/Poll VS Epoll&lt;/h3&gt;
&lt;p&gt;끝내기 전에 고전적인 방식(select, poll)과 epoll의 차이점을 간단히 정리해보고 가자.
select, poll의 방식은 서버가 정기적인 시간마다 서버와 연결된 socket들에 변화가 있는지 하나하나 확인한다. socket이 10000개라면 정기적인 시간마다 10000개를 확인하는 것이다. 반면에 epoll은 소켓들을 관리하는 자료구조를 따로 만들고. 소켓에 들어오는 이벤트들을 검사한다. libuv에 전달해줘야하는 이벤트인지 아닌지. 맞다면 관리 자료구조에 해당 fd를 적어둔다. 그리고 정기적으로 서버가 새로운 이벤트에 대해 요청하면 그 데이터만 전달한다. 다른 검사 과정은 없다. 이러니 획기적으로 fd 검사 횟수가 줄어들수 밖에 없다. 처음엔 소켓을 관리하는 데이터를 만들고. 모든 이벤트를 필터링하는 것도 부하가 들지 않을까 생각했지만 필터링 하나 넣는것이 그렇게 큰 부하가 드는 일이 아니라서 월등히 성능이 좋아질수 밖에 없다는 걸 받아들였다.&lt;/p&gt;

&lt;p&gt;필터링 과정이 부하가 되지는 않을까 생각해봤지만 매번 모든 fd를 확인해서 까보는 것에 비하면 비교할수 없을 정도로 부하가 작다.&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Jan 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//from-the-libuv-server-series-2</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//from-the-libuv-server-series-2</guid>
        
        <category>node.js</category>
        
        <category>TCP/IP</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>API 서버가 데이터를 받기까지 (운영체제에서) - 서버가 작동하는 흐름 1</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;&lt;u&gt;(현재글) 1.서버가 데이터를 받기까지 [운영체제에서]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;2.서버가 데이터를 받기까지 [libuv]&lt;/a&gt; &lt;br /&gt;
3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt;
4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;api-서버가-데이터를-받기까지&quot;&gt;API 서버가 데이터를 받기까지.&lt;/h1&gt;
&lt;p&gt;우리가 만든 Node.js 서버가 데이터를 받기위해선 포트 번호(ex. 3000, 8080)와 바인딩되어야한다. 그래야만 운영체제가 node.js 서버 프로그램이 어디 있는지 알수있고 데이터를 보낼수 있다.
이제 포트와 연결된 상태로 서버가 &lt;strong&gt;실행&lt;/strong&gt;중이라면 서버에서는 데이터를 받을 준비가 됐다.&lt;/p&gt;

&lt;p&gt;송신자측을 이야기해보자.
송신자(클라이언트)는 데이터를 보내기전에 서버와 연결을 만들어야한다. 이때 TCP 연결이 필요하다. TCP 연결은 3 way handeshake로 만들어진다. &lt;strong&gt;3 way handshake가 완료되면 클라이언트와 서버에 socket이 생긴다.&lt;/strong&gt; 이 소켓(socket)이라는 건 connection이 가능하다는 증빙이라고 생각하면 된다. 소켓의 내용물는 클라이언트와 서버 양측 네트워크 정보[송신자 IP, 송신자 port, 수신자 IP, 수신자 port] 4가지이다. 이 증빙이 있으면 클라이언트에서 서버로 데이터를 보낼수 있게 된다.&lt;/p&gt;

&lt;p&gt;송신자가 데이터를 보냈을 때 수신자측에서 소켓을 가지고 있지 않은 상태라면(소켓데이터가 유실되거나) 연결 리셋(TCP reset) 응답이 온다. 이때 송신자는 다시 3 way handshake을 진행해야한다. 그 뒤 양쪽에 소켓이 생성되면 데이터를 보낼수 있다.&lt;/p&gt;

&lt;p&gt;클라이언트와 서버간의 연결이 확보되면 아래 layer들에서 데이터에 여러가지 정보를 덧붙인다. &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP layer는 데이터 전송의 안정성 관련 정보,&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;IP layer는 목적지 ip까지 잘도착하는데에 필요한 정보,&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;마지막으로 Data link layer는 목적지 IP에서 서버가 작동하고 있는 구체적인 하드웨어 정보를 담당한다. 그리고 네트워크에서 움직일수 있는 형태의 데이터로의 변환까지 책임진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP/IP stack에 대해 아주 짧게 정리하고 넘어가보자. (디테일에 대해선 다른 좋은글들이 많다. &lt;a href=&quot;https://d2.naver.com/helloworld/47667&quot;&gt;네이버 D2 TCP/IP 네트워크 스택 이해하기&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application layer&lt;/h2&gt;
&lt;p&gt;우리가 쓰는 chrome 등 모든 프로그램/앱이 application이다. application layer에서는 클라이언트와 서버가 소통하기로 한 방식에 맞게 보내는 데이터를 맞춰주는 역할을 한다. http, ftp등이 있는데 이들 모두 커뮤티케이션하는 방식이 다르므로 개별 구조에 맞추는 작업이다. Node.js에서는 http library가 이 일을 해준다.&lt;/p&gt;

&lt;p&gt;데이터를 규약에 맞게 만들고 나면 위에서 얘기한 &lt;strong&gt;socket&lt;/strong&gt;으로 데이터를 보낸다. 소켓의 &lt;strong&gt;“write socket buffer”&lt;/strong&gt; 으로 보내게 되는데 이때 system call을 전송이 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp-layer&quot;&gt;TCP layer&lt;/h2&gt;
&lt;p&gt;write socket buffer에 데이터가 오게 되면 차례차례 필요한 데이터를 붙여준다. TCP layer는 데이터 전송의 안정성을 높여주는 것이 목적이라고 했다. 그래서 붙여주는 데이터들이 “순서 데이터”, “확인 응답 데이터”, “포트 번호”등이다.&lt;/p&gt;

&lt;h3 id=&quot;순서-데이터&quot;&gt;순서 데이터&lt;/h3&gt;
&lt;p&gt;보통 클라이언트 요청이 하나의 패킷으로 전달되지않는다. 여러개로 나뉘어서 보내지는데, 네트워크 상태에 따라 순서대로 보내지지 않을 때가 많다. 이럴 때 순서 데이터를 이용한다. 받는 곳(서버)에서 데이터를 순서대로 다시 조립할수 있게 해준다. 그리고 순서 데이터로 빠진 데이터가 있는지도 알수 있기때문에 만약에 누락된 데이터가 있다면 이를 이용해 클라이언트에 다시 요청하는 프로세스가 쉽게 이루어진다.&lt;/p&gt;

&lt;h3 id=&quot;포트-번호&quot;&gt;포트 번호&lt;/h3&gt;
&lt;p&gt;목적지 컴퓨터의 어떤 프로그램으로 가야하는지에 대한 정보이다. 소켓은 송신자 IP, 송신자 포트번호,수신자 IP, 수신자 포트번호 로 구성된다. 포트번호가 있어야 소켓에 전송가능하다.&lt;/p&gt;

&lt;h3 id=&quot;확인-응답-데이터&quot;&gt;확인 응답 데이터&lt;/h3&gt;
&lt;p&gt;수신측에서 데이터를 받았다고 송신측에 메시지를 보냄으로써 안정성을 확보한다. 확인 응답데이터에는 에러 체크 또한 포함된다. 이게 당연한 것 같지만, 보낸 ‘데이터를 받았음’을 응답해주지 않는 프로토콜(ex. UDP)도 많다. 그러므로 당연한 것 같아도 아주 특별한 기능이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ip-layer&quot;&gt;IP layer&lt;/h2&gt;
&lt;p&gt;TCP layer를 지나 IP 레이어로 오게된다. TCP에서 받은 데이터에 출발지/목적지 IP가 붙여진다. 인터넷 네트워크는 복잡하게 구성되어있기 때문에 여러 IP들을 거쳐서 목적지 IP로 도착하게 해주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;IP layer에는 목적지로 가기 위한 다음 IP를 알수 있는 &lt;strong&gt;Routing table&lt;/strong&gt;이 존재한다. 이를 이용하여 목적지 IP로 가기 위한 다음 환승역을 찾는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-link-layer&quot;&gt;Data link layer&lt;/h2&gt;
&lt;p&gt;이 부분은 대부분 물리적인 것과 관련돼있다. MAC 주소와 NIC가 핵심이다.&lt;/p&gt;

&lt;h3 id=&quot;mac-주소&quot;&gt;MAC 주소&lt;/h3&gt;
&lt;p&gt;우리가 이용하는 개별 컴퓨터는 MAC 주소라는게 있는데 이 값은 컴퓨터마다 유니크하다. 여러대의 컴퓨터는 같은 IP를 공유하게 되므로 IP만으로 목적지가 어디인지 정확히 알수 없다. 은마아파트 101동이라는 정보만으로 친구 집의 위치를 알수 없는 것처럼말이다. IP가 “은마아파트 101동”이라면 “1203호”는 MAC주소이다.&lt;/p&gt;

&lt;p&gt;MAC주소가 덧붙여진 뒤 &lt;strong&gt;NIC&lt;/strong&gt;로 전달한다. NIC에서는 데이터를 인터넷 네트워크 선에서 이동가능한 bit들로 변환한다. 그리고 최종적으로 인터넷선으로 전달한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;서버에서-데이터-도착한-뒤&quot;&gt;서버에서 데이터 도착한 뒤&lt;/h1&gt;
&lt;p&gt;TCP/IP 스택에서 붙여진 여러가지 데이터를 이용해서 목적지 서버에 데이터가 잘 도착했다. 도착한 곳은 서버의 NIC이다. NIC에 도착하면 제일 먼저 NIC Buffer에 임시로 데이터가 저장된다. 그리고 NIC에서 &lt;em&gt;Interrupt&lt;/em&gt;를 일으켜 운영체제에 새로운 데이터가 왔음을 알린다. 이 알림을 받은 TCP/IP 스택에서 데이터를 가져간다. 그리고 TCP/IP 작업을 거꾸로 수행한다. &lt;strong&gt;클라이언트에서는 여러 데이터들을 덧붙이는 방식으로 TCP/IP 스택이 작동했다면, 서버측에서는 그 데이터를 떼어내며 작동한다. 떼어낸 데이터들은 서버 프로그램에 도착하는데 이용된다.&lt;/strong&gt; 여러 작업을 마친 뒤 TCP layer에서 port번호까지 맞는지 확인됐다면 &lt;u&gt;TCP layer와 서버 프로그램의 연결지점인 Socket&lt;/u&gt;에 데이터를 보낸다. 소켓 파일에 저장되는 것이 아니라 소켓의 구조체중 하나인 &lt;strong&gt;Receive socket buffer&lt;/strong&gt;에 데이터가 쌓이게 된다.
Receive socket buffer에 쌓인 데이터는 이제 운영체제의 책임에서 벗어났다. 이제부터는 Node.js 서버가 행동을 할 차례이다. &lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Node.js 서버 뿐만 아니라 대부분의 프로그램은 &lt;strong&gt;TCP layer와 서버 프로그램의 연결지점인 socket&lt;/strong&gt;에 데이터가 임시로 저장된 뒤 개별 프로그램에서 데이터를 가져와 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;계층별로 정보가 덧붙여진 데이터를 부르는 명칭이 있다. &lt;br /&gt;TCP -&amp;gt; 세그먼트 / IP -&amp;gt; 패킷 / Data link -&amp;gt; 프레임 / NIC -&amp;gt; 비트&lt;br /&gt;
(관련된 글을 처음 읽는 사람도 있을 까봐 명칭을 쓰지않고 작성한 글이다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
프로그램이 데이터를 가져와 처리하는 방식은 다음글에서.&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jan 2024 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//before-arriving-server-server-series-1</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//before-arriving-server-server-series-1</guid>
        
        <category>node.js</category>
        
        <category>TCP/IP</category>
        
        <category>OS</category>
        
        
      </item>
    
      <item>
        <title>백엔드 동시성 - 1. Postgres 가시성</title>
        <description>&lt;p&gt;데이터베이스단에서 동시성 확보는 디비 자체적으로 해주는 것과 프로그래머가 직접 코드로 짜야하는 걸로 나뉜다. 그중 데이터베이스에서 제공해주는 부분을 알아본다.&lt;/p&gt;

&lt;p&gt;“1. 기본적인 잠금(shared/exclusive lock)”과 “2. Isolation level 구현(MVCC)” 이 두가지가 데이터베이스에서 이미 완성시켜둔 동시성 도구들이다. 이 둘의 조합으로 기본적인 동시성 제어를 구성한다.&lt;/p&gt;

&lt;h2 id=&quot;1-기본-잠금---shared-lock-exclusive-lock&quot;&gt;1. 기본 잠금 - Shared Lock, Exclusive Lock&lt;/h2&gt;
&lt;p&gt;모든 데이터베이스에서는 update, delete문이 실행되는 동안 해당 row를 잠궈버린다. 다른 쿼리중에서 update, delete문이 같은 row에 대해 실행하려한다면 이전 쿼리의 트랜잭션이 끝날때까지 기다려야한다. INSERT, UPDATE, DELETE문은 트랜잭션을 명시적으로 설정하지않아도 데이터베이스가 알아서 트랜잭션을 실행하고 작업이 완료되면 트랜잭션을 끝낸다. 반대로 기본적으로 아무것도 설정하지않은(트랜잭션 X, for update 설정 X) select문은 트랜잭션도, Lock도 이용하지않는다.&lt;/p&gt;

&lt;p&gt;여기서 쓰이는 잠금은 “Shared Lock”과 “Exclusive Lock”이다.&lt;/p&gt;

&lt;p&gt;Shared Lock: 내가 이 데이터 보고 있으니까 데이터 바꾸지마. 보기만 해. 근데 너도 같이 잠글수 있어(shared lock만)&lt;br /&gt;
Exclusive Lock: 내가 데이터 수정할거니까 보기만하고 수정하지마..&lt;/p&gt;

&lt;p&gt;두가지 잠금 모두 다른 트랜잭션에서 &lt;strong&gt;데이터 수정을 불가능&lt;/strong&gt;하게 만든다. &lt;strong&gt;둘의 차이점은 잠금을 걸었을 때 다른 잠금이 동시에 잠금을 걸수 있는지 없는지 여부다.&lt;/strong&gt; Exclusive Lock은 이름처럼 어떠한 락도 공존할수 없다. Shared Lock은 이름처럼 공존할수 있다. 다만 공존할수 있는 Lock은 Shared Lock뿐이다.
만약 트랜잭션A에서 row1에 Shared Lock을 건 상태라면 다른 트랜잭션에서도 row1에 Shared Lock을 걸수 있다. Shared Lock이 겹쳤을 때는 마지막 Shared Lock을 건 트랜잭션이 Lock을 풀면 해당 row의 shared Lock이 풀린다. Exclusive Lock은 동시에 다른 잠금을 걸수 없다.&lt;/p&gt;

&lt;h2 id=&quot;2-mvcc-multi-version-concurrency-control&quot;&gt;2. MVCC (Multi Version Concurrency Control)&lt;/h2&gt;
&lt;p&gt;MVCC는 대부분의 관계형 데이터베이스에서 통용되는 규칙인 “Isolation Level”을 구현한 것이다.&lt;/p&gt;

&lt;h3 id=&quot;mvcc의-논리적-기반&quot;&gt;MVCC의 논리적 기반&lt;/h3&gt;
&lt;p&gt;MVCC는 데이터베이스의 기본 저장방식인 &lt;strong&gt;COMMIT&lt;/strong&gt;을 이용한다. 데이터베이스는 데이터를 저장, 수정할 때 1차로 메모리에 저장한뒤에 트랜젝션이 COMMIT되면 DISK에 저장한다. (매커니즘에 따라 여러 커밋이 뭉쳐서 disk에 저장되기도 한다.)
커밋한 데이터만 읽어들일건지, 커밋하지않았지만 메모리에 저장된 데이터도 읽어들일건지에 따라 Isolation Level이 나뉜다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Committed&lt;/strong&gt;는 커밋된 데이터만 읽는다.&lt;br /&gt;
&lt;strong&gt;Repeatable Read&lt;/strong&gt;는 커밋되지 않은 데이터도 읽는다. 하지만 트랜잭션이 시작된 시점에도 존재했던 데이터만 읽는다.&lt;/p&gt;

&lt;p&gt;더 자세히 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;mvcc의-물리적-기반&quot;&gt;MVCC의 물리적 기반&lt;/h3&gt;
&lt;p&gt;Postgres MVCC는 Hint bit, commit log, snapshot, xmin, xmax 데이터를 이용하여 유효한 데이터를 판단한다.&lt;/p&gt;

&lt;h5 id=&quot;xmin-xmax&quot;&gt;xmin, xmax&lt;/h5&gt;
&lt;p&gt;먼저 xmin, xmax부터 알야아한다.(hint bit에서도 쓰이고 snapshot에서도 쓰이기 때문에) xmin, xmax는 모든 row가 가지고 있는 컬럼이다. 일반 컬럼이 아니고 시스템 컬럼이라서 명시적으로 검색하지않는 이상 기본적으로는 보이지않는다. &lt;br /&gt;
INSERT문이 실행되면서 row가 생성될 때 해당 트랜잭션의 ID를 해당 row의 xmin에 설정한다. xmin는 직관적으로 이해가 가지만 반면에 xmax는 조금 생소할수 있다. &lt;strong&gt;postgres는 기본적으로 update 작업을 할 때 기존 데이터를 변경하지 않는다.&lt;/strong&gt; 변경하는 대신에 기존 데이터의 xmax에 현재 트랜잭션 ID를 설정한다. 그리고 업데이드된 데이터를 가진 새로운 row를 생성한다. INSERT와 마찬가지로 xmin은 현재 트랜잭션 ID가 설정된다. DELETE는 기존 row의 xmax에 현재 트랜잭션 ID를 설정하고 끝이다. &lt;br /&gt;
정리하자면 특정 row에 xmax값이 존재한다면 그 값은 가장 최신의 값이 아니라고 생각할수 있다. 
여기서 짚고 넘어가야할 하나는 &lt;strong&gt;xmin 값이 있다는게 커밋됐다는 의미는 아니다.&lt;/strong&gt; row들이 커밋되기전에 임시로 저장되어있듯이 row들의 모든 컬럼들도(시스템컬럼 또한) 임시로 저장된 상태이다. &lt;strong&gt;커밋 여부는 커밋로그와 hint bit에서만 확실시 할수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;xmin, xmax를 대략 알았다면 다시 처음으로 돌아가자. 쿼리문에 대해 MVCC는 아래와 같은 순서로 작동한다.&lt;/p&gt;

&lt;h4 id=&quot;0-select문을-where절과-같이-실행&quot;&gt;0. SELECT문을 WHERE절과 같이 실행.&lt;/h4&gt;

&lt;h4 id=&quot;1-where-조건-확인&quot;&gt;1. WHERE 조건 확인&lt;/h4&gt;
&lt;p&gt;WHERE절의 조건대로 데이터를 필터링한다.&lt;/p&gt;

&lt;h3 id=&quot;21-커밋-여부-확인---hint-bit&quot;&gt;2.1 커밋 여부 확인 - Hint bit&lt;/h3&gt;
&lt;p&gt;WHERE 필터링된 row들의 header를 확인하여 hint bit를 확인하여 커밋 여부를 파악한다.&lt;/p&gt;

&lt;p&gt;모든 개별 row들은 개별 http 요청들이 헤더를 가지듯이 header를 가지고 있다. header안에 hint bit가 있는데 아래 4가지를 boolean값으로 가지고 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;XMIN_COMMITTED -- creating transaction is known committed
XMIN_ABORTED -- creating transaction is known aborted
XMAX_COMMITTED -- same, for the deleting transaction
XMAX_ABORTED -- ditto
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이름만 봐도 알수 있듯이 XMIN_COMMITTED가 true이면 커밋된 것을 의미하고 XMIN_ABORTED가 true라면 롤백된 트랜잭션을 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;22-커밋-여부-확인---commit-log&quot;&gt;2.2 커밋 여부 확인 - commit log&lt;/h4&gt;
&lt;p&gt;사실 hint bit는 commit log의 캐시버전이다. 그래서 hint bit부터 확인하고 hint bit가 없다면 커밋 로그를 확인하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;3-snapshot&quot;&gt;3. snapshot&lt;/h4&gt;
&lt;p&gt;(스냅샷은 내용이 좀 많다.)
데이터베이스 복구에 이용하는 스냅샷과는 이름만 같다. 하지만 특정시점의 데이터를 나타낸다는 것은 비슷하다. MVCC의 스냅샷은 트랜잭션이 실행되는 동안 “특정시점에 생성”되어 데이터 가시성을 판단하는 과정을 거친다. 먼저 스냅샷의 내용물은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedSnapshotData&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TransactionId&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 현재 활성화돼있는 트랜잭션 중 가장 작은 트랜잭션 ID&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TransactionId&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 현재 활성화돼있는 트랜잭션 중 가장 큰 트랜잭션 ID&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uint32&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;xcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;subxcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;suboverflowed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;takenDuringRecovery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CommandId&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;curcid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TimestampTz&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whenTaken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;XLogRecPtr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;lsn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedSnapshotData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// https://github.com/postgres/postgres/blob/06c418e163e913966e17cb2d3fb1c5f8a8d58308/src/backend/utils/time/snapmgr.c&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 이야기한 xmin, xmax를 가지고 있다. 위 단계에서 필터링된 row들은 모두 xmin, xmax 컬럼을 가지고 있는데(어떠한 모든 데이터들도 가지고 있다.) 이 컬럼들과 스냅샷의 xmin, xmax를 비교하여 어떤 row를 보여줄지 정한다.&lt;/p&gt;

&lt;p&gt;그리고 스냅샷을 언제 만드는지에 차이를 둬 Reqd Committed, Repeatable Read를 나눠 구현한다. (MVCC는 데이터베이스 Isolation을 구현한 것이니까)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Snapshot의 xmin, xmax 비교” + “스냅샷을 만드는 시점의 차이”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Repeatable Read&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Repeatable Read 레벨에서의 스냅샷 생성 시기는 트랜잭션 마다 단 한번이다. 트랜잭션이 시작할 때 스냅샷을 생성하고 한 트랜잭션 안에 있는 모든 쿼리가 같은 스냅샷을 이용하게 된다. 스냅샷에 존재하는 xmin값은 스냅샷 생성시기에 활성화되어 있던 모든 트랜잭션 중 가장 먼저 실행되고 있떤 값이다. 그렇기 때문에 스냅샷의 xid보다 큰 값의 xid를 가지고 있는 row는 아직 커밋되지않은 것으로 간주된다. 그리하여 결과에 포함되지않는다.&lt;/p&gt;

&lt;p&gt;그리고 제일 핵심으로는 Repeatable Read는 한 트랜잭션내에서는 같은 결과를 보여줘야하기때문에 최저활성 트랜잭션 ID보다 이후에 생성/수정된 데이터는 보여주지 않는 방식으로 구현한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Committed&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Read Committed는 스냅샷을 이용하지 않는다고 생각해도 된다. &lt;strong&gt;개별 쿼리가 실행되는 시점에 커밋된 데이터인지 아닌지만 판단하면 되기때문이다.&lt;/strong&gt; 같은 트랜잭션안의 두 쿼리가 실행될 때 첫 번째 쿼리가 실행된 후에 다른 트랜잭션에서 새로운 데이터를 만들고 커밋하면 첫번째 쿼리에서는 안보이던 데이터가 두번째 쿼리에서는 보이게된다.(같은 조건의 쿼리들이 같은 트랜잭션안에서 다른 값을 보여줄수 있다.) Read Committed는 커밋로그와 Hint bit만으로도 구현이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Serializable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Serialzable의 스냅샷 이용방식은 Repeatable Read와 거의 똑같다. 트랜잭신이 시작했을 때만 스냅샷을 생성하고 해당 트랜잭션동안 그 스냅샷을 이용한다.(Repeatable Read와 같이 스냅샷 이전에 커밋된 데이터만 보인다.) 한가지 다른점은 하나의 트랜잭션이 건드린 데이터는 해당 트랜잭션이 끝나기전까지 다른 트랜잭션이 못건드리게 한다. 건드리면 늦게 건드린 명령은 롤백된다. (SSI를 찾아보면 좋다.)&lt;/p&gt;

&lt;h4 id=&quot;4-완전-마지막-단계가-하나-있다&quot;&gt;4. 완전 마지막 단계가 하나 있다.&lt;/h4&gt;
&lt;p&gt;위 단계를 거치면서 필터링된 데이터들이 남게 된다. 그 데이터중에서는 여러개의 row가 사실은 하나의 데이터일때가 있다.(postgres에서는 Update/Delete시 기존 데이터를 지우는게 아니라 xmax에 transaction id를 설정하니깐) 그럴 때 하나의 값만을 보여주기 위해 xmax값이 존재하는 데이터는 보이지않고 xmin만 설정돼 있는 데이터를 보여주게 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Dec 2023 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//mvcc</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//mvcc</guid>
        
        <category>백엔드</category>
        
        <category>데이터베이스</category>
        
        <category>Hit Bits</category>
        
        <category>database</category>
        
        <category>MVCC</category>
        
        
      </item>
    
      <item>
        <title>Socket.io 무중단 배포</title>
        <description>&lt;p&gt;채팅 서버 무중단 배포 방식을 정리하고 가자.&lt;/p&gt;

&lt;p&gt;BlueGreen, Canary과 같은 배포 방식에 관련된 글이라기보다는 무중단 배포에 있어 채팅 서버의 어떤 점들을 유의해야하는지에 대한 글이겠다. (Socket.io를 기준으로)&lt;/p&gt;

&lt;p&gt;Socket 배포에 있어서 중요한 건 “client-server간의 관련 데이터 관리”, “client-server connection 관리”이 두가지가 되겠다.&lt;/p&gt;

&lt;h2 id=&quot;socketio-관련-데이터-관리&quot;&gt;socket.io 관련 데이터 관리.&lt;/h2&gt;
&lt;p&gt;socket.io에서는 실시간 통신을 위해 필요한 데이터들이 몇가지 있다. 보통 session이라고 한다.&lt;/p&gt;

&lt;p&gt;SocketId: 기본적으로 클라-서버가 연결됐을 때 만들어진다.
Namespaces: 소켓에서 구획을 나눠서 이용할수 있게 해주는 기준이다. 보통 기능에 따라 나눈다. (e.g. normal-chat, group-chat)
Rooms: namespace안에서 한번 더 구분되는 단위라고 생각하면 된다. (e.g. normal-chat(namespace)중에서 1번 room)
Event Handler: 특정 이벤트에 대한 행동&lt;/p&gt;

&lt;p&gt;socket.io에서는 session들을 &lt;strong&gt;adapter&lt;/strong&gt;라는 도구로 관리한다. 하나의 인스턴스에서 socket.io가 작동한다면 기본적으로 memory adapter로 관리된다. 인스턴스 개수가 두개가 될때부터는 데이터 동기화를 위해 외부 저장장치로 adapter를 설정해야한다. redis, db등 여러가지가 있고 redis가 주로 많이 쓰인다. 
socketId, namespace등이 adapter를 통해 실시간으로 동기화되어 데이터를 목적지 client들에게 전달할 수 있게된다.
실시간 동기화되는 데이터저장소가 있기때문에 업데이트시에도 기존 상태 데이터가 잘 보관될수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;connection-관리&quot;&gt;Connection 관리.&lt;/h2&gt;
&lt;p&gt;Socket.io로 연결된 클라이언트는 socketId를 받게 된다. 서버쪽에서는 socketId를 adapter에 저장해두어 커낵션 정보를 관리한다. socket.io 서버는 아래와 같은 형식으로 데이터들을 저장한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;sids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SocketId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 소켓ID와 room 매칭 데이터&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;sids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;socketId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socketId2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;roomId3&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SocketId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// room과 소켓ID 매칭 데이터&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;roomId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socketId1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socketId2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무중단 배포가 시작되고 한 인스턴스가 업데이트 된다면 해당 인스턴스와 연결된 클라이언트들은 socket 연결이 끊긴다. 그런데 Socket.io 자체에는 자동 재연결 기능이 구현되어있다. 연결이 끊긴다면 바로 재연결을 시도하고 재연결이 완료되면 새로운 socketId를 받게 된다.
(재연결 시도 할 때, 로드밸런서의 도움으로 지금 업데이트중인 인스턴스가 아니라 이용가능한/살아있는 다른 인스턴스와 연결이 된다.)&lt;/p&gt;

&lt;p&gt;이때 우리가 서버쪽에 추가적인 작업을 하나 셋팅해둬야한다. &lt;strong&gt;“reconnection” 이벤트가 발생했을 때 유저가 이용중이던 채팅방에 다시 join() 시켜주는 기능이 필요하다.&lt;/strong&gt;
우선 중앙 저장소에 현재 접속되어있는 채팅방-유저 데이터를 저장하고 있어야한다. 채팅방1: [유저1, 유저2, 유저3] 이런 데이터를 실시간으로 유지하고 있다면 reconnection 이벤트가 발생했을 때 해당 유저가 이용중이던 room에 바로 다시 join() 시켜줄수 있게 된다.
이렇게 된다면 &lt;strong&gt;&lt;em&gt;socket 서버에 다시 연결하는 시간 + 내가 이용중인 채팅방 정보 가져오는 시간 + 해당 채팅방으로 다시 join() 하는 시간 으로 중단 시간이 단축된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Jul 2023 00:00:00 -0500</pubDate>
        <link>http://0.0.0.0:4000//socketio-non-stop-deployment</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//socketio-non-stop-deployment</guid>
        
        <category>node.js</category>
        
        <category>Socket.io</category>
        
        
      </item>
    
      <item>
        <title>Nest.js 모듈 구조 관리 (Avoiding circular dependency)</title>
        <description>&lt;p&gt;어떤 아키텍쳐를 쓰던 DI(dependency injection)는 대부분 이용된다. Nest.js의 기본 구조도 그렇다.
그런데 DI로 개발하다보면 의존성이 꼬이는 일이 발생하는 경우가 있다. 대부분이  &lt;strong&gt;circular dependency&lt;/strong&gt;로 나타난다.
이 때 &lt;em&gt;lazy loading&lt;/em&gt;을 이용해서 circular dependency 발생 없이 개발할수도 있지만 상호의존은 최악의 구조이기 때문에 최대한 불가피한 경우에만 써야한다.&lt;/p&gt;

&lt;p&gt;내가 관리하는 프로젝트들에서 상호 의존을 피하기 위한 규칙들은 아래와 같다.&lt;/p&gt;

&lt;h2 id=&quot;1-테이블-마다-모듈을-만든다는-생각부터-버려야한다&quot;&gt;1. 테이블 마다 모듈을 만든다는 생각부터 버려야한다.&lt;/h2&gt;
&lt;p&gt;나 또한 개발 초기에는 대부분의 백엔드 강의가 CRUD 강의였기때문에 테이블과 거의 1대1 매칭이 됐다. 그렇게 배웠다보니 나도 실무에서 그렇게 해왔다. 하지만 어느 순간 상호 의존하는 상황이 발생했다.(지금도 꽤 발생한다..) 가장 큰 이유는 개별 모듈이 너무 커졌기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;종류에-따라-분리&quot;&gt;종류에 따라 분리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/writing-images/user-module.png&quot; alt=&quot;1&quot; /&gt;
User, Order, Product 이 3가지의 테이블을 가진 서비스를 생각해보자. 모듈을 테이블대로 3개만 만들어서 이용한다면 초기에는 괜찮았겠지만 서비스가 커질수록 기능이 아주 많아지면서 개별 모듈의 기능들 또한 많아진다(책임이 커진다).
예를 들면, User의 종류도 처음엔 한 종류였다. 그런데 한달뒤에 비로그인 유저가 주문할수 있는 기능도 생겨날수 있다. 혹은 유저 등급에 따라 기능이 분리될수도 있게 된다.(e.g. PaidUser, UnpaidUser).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“기능이 많다” 라는 건 “다른 모듈의 기능을 필요할(의존할) 확률이 높아진다”와 같은 말이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PaidUser, UnpaidUser, NonLoginedUser 처럼 여러개로 나눠 모듈을 관리한다면 &lt;strong&gt;PaidUser에서만 결제 정보에 대해 의존하면 된다.&lt;/strong&gt; UnpaidUser와 NonLoginedUser 모듈에서는 결제 정보를 의존하지 않아도 된다. 반대로 UnpaidUser에서만 필요한 모듈은 Unpaid모듈에서만 의존하고 다른 곳에서는 의존하지 않는다. &lt;strong&gt;정말 필요한 기능에서만 의존성을 주입하게 되는 구조가 성립된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하지만 한 뿌리에서 나온 모듈들이다보니 공통되는 기능들이 꽤나 존재하게 된다. 그럴 때는 User 모듈을 공통 기능/API 모듈로 사용한다.&lt;/strong&gt; 혹은 좀 더 명시적이고 싶다면 UserCore, UserShare 모듈로 이름 지어도 좋다.&lt;/p&gt;

&lt;h3 id=&quot;혼합된-형식으로-만들어-분리&quot;&gt;혼합된 형식으로 만들어 분리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/writing-images/order-and-user-module.png&quot; alt=&quot;1&quot; /&gt;
한뿌리에서 나온 모듈을 종류에 따라 분리하는 방법이 모듈 관리의 절반을 차지한다면, 나머지 절반은 &lt;strong&gt;&lt;em&gt;혼합된 형식&lt;/em&gt;&lt;/strong&gt;이 차지한다. User종류들과 Order이 합쳐진 UserOrder, NonUserOrder 모듈처럼 나뉠수 있다. &lt;u&gt;쇼핑몰에서 흔히 볼수 있는 비회원 구매 기능을 생각하면 좋다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;두가지 데이터를 혼합한 모듈을 만들면 모듈의 기능이 분리되서 관리가 쉬워진다. 나누지 않았다면 Order 모듈에서 모두 책임을 져야하니 말이다.&lt;/p&gt;

&lt;h2 id=&quot;2-방향-또한-중요하다&quot;&gt;2. 방향 또한 중요하다.&lt;/h2&gt;
&lt;p&gt;User, Order에서 둘의 관계는 User가 Order를 여러개 가진다. &lt;strong&gt;일대다(완벽히 일대다는아니지만)와 같은 관계에서는 ‘다’가 ‘일’을 의존하도록 해야한다.&lt;/strong&gt; 논리적으로 대부분이 그렇다. Order API를 개발할 때 User 정보를 가져올 확률이 높지 User API에서 Order 정보를 가져올 일은 그리 많지않다. 있을수 있지만 비율적으로 비교가 불가하다. 그러니 ‘다’ 방향에서 ‘일’을 의존해야한다. ‘일’에서 ‘다’를 의존하게 된다면 기존 구조가 불량할 확률이 높다.&lt;/p&gt;

&lt;h2 id=&quot;3-1-to-1은-보통-하나의-모듈에서-처리해도-되긴하는데&quot;&gt;3. 1 to 1은 보통 하나의 모듈에서 처리해도 되긴하는데..&lt;/h2&gt;
&lt;p&gt;이미 다들 그렇게 하시겠지만.. User, Profile이 있다면 User 모듈에서 Profile에 대한 모든 기능을 처리하면된다. 그런데 만약에 Profile 기능이 꽤나 많다면 UserProfile이란 혼합 모듈을 만들면 더 깔끔해진다.&lt;/p&gt;

&lt;p&gt;여기서 둘의 차이점을 생각해보고 지나가자. 
“1. Order모듈에서 Receipt모듈 처리” vs “2. 개별 모듈로 분리”&lt;/p&gt;

&lt;p&gt;1의 장점은 URL이 깔끔해진다. 
“GET order/:id/receipt” vs “GET receipt?orderId=123” 이렇게 비교하면 전자가 직관적이고 깔끔하다. 그러나 URL의 직관성도 중요하긴하지만, 백엔드 구조의 깔끔함이 우선임을 생각하면(추후에 확장가능성까지 생각한다면) 후자가 훨씬 좋은 선택지라고 할수 있다.&lt;/p&gt;

&lt;h2 id=&quot;4-작은-모듈을-유지해야-변경에-용이하다&quot;&gt;4. 작은 모듈을 유지해야 변경에 용이하다.&lt;/h2&gt;
&lt;p&gt;위 다른 이유들도 중요하지만 모든 것이 계획대로 되지만은 않는다. 바쁘다보면 실수하고 안바빠도 실수한다. 그러려면 변경이 쉬워야하는데 큰 모듈들로 구조가 유지된다면 구조를 잘못짰을 때 변경하기가 쉽지않다. 여러 모듈로 나뉜 상태라면 각 모듈마다 기능이 적을테니 의존성이 꼬였을 때 새로운 모듈로 이전하기가 쉬워진다.&lt;/p&gt;

&lt;h2 id=&quot;5-여러군데서-쓰이는-기능은-share-모듈로&quot;&gt;5. 여러군데서 쓰이는 기능은 Share 모듈로.&lt;/h2&gt;
&lt;p&gt;여러 코드베이스에서 Shared, Common 같은 폴더를 봤을 것이다. 이 모듈들은 최대한 다른 모듈을 의존하지않은 상태로 유지된다. 그리고 모든 다른 모듈들이 이 모듈을 의존하는 형태로 관리된다. 한군데 모듈에서만 쓰이는 기능이 아니라면 바로 이런 공통 모듈에 박아두면 Circular dependency가 발생할 확률이 줄어든다.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Jun 2023 00:00:00 -0500</pubDate>
        <link>http://0.0.0.0:4000//dependnecy-manage-on-nestjs</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//dependnecy-manage-on-nestjs</guid>
        
        <category>nest.js</category>
        
        <category>circular dependency</category>
        
        <category>module</category>
        
        
      </item>
    
      <item>
        <title>Join 알고리즘 대표적 3가지 특징/최적화</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/join-algorithms-1&quot;&gt;1. Join 알고리즘의 종류&lt;/a&gt; &lt;br /&gt;
&lt;u&gt;(현재글) 2. Join 알고리즘 최적화&lt;/u&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3가지-조인-비교&quot;&gt;3가지 조인 비교&lt;/h1&gt;

&lt;p&gt;3가지 조인 알고리즘이 어떤 상황에 선택되는지(유리한지) 알아보자.
일단은 시간복잡도부터 따져보면. Nested Loop은 O(N*M), Hash와 Sort-Merge는 O(N+M)이다.&lt;/p&gt;

&lt;p&gt;조인 알고리즘은 &lt;strong&gt;WHERE문으로 필터링된 데이터의 갯수&lt;/strong&gt;에 따라 첫번째로 갈린다.
WHERE문으로 필터링이 많이돼서 Join할 데이터가 적다면 Nested Loop 조인을 이용한다. WHERE문으로 필터링된 뒤에도 데이터가 많이 남아있다면 Hash 조인과 Merge 조인을 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;nested-loop&quot;&gt;Nested loop&lt;/h2&gt;

&lt;p&gt;Nested Loop Join은 보통 WHERE문으로 필터링된 데이터가 적을 때 이용된다. 이유는 단순하다. &lt;strong&gt;Nested Loop은 특별한 초기 프로세스가 없기 때문이다.&lt;/strong&gt; Hash 조인은 &lt;strong&gt;Hash 테이블을 만들어야하고&lt;/strong&gt;, Merge 조인은 조인하는 테이블들을 Join 키를 기준으로 &lt;strong&gt;정렬&lt;/strong&gt;해야한다. Nested Loop은 아무것도 없다. 그냥 하나하나 비교하는게 끝이다.
시간복잡도가 다른 알고리즘보다 높음에도 불구하고(O(N*M)) 다른 알고리즘과 다르게 초기 작업이 없기때문에 가볍게 진행될수 있다.
&lt;strong&gt;다만 데이터가 많아지면 시간복잡도의 성능 저하가 기초작업에 필요한 성능 저하보다 커지게된다.&lt;/strong&gt; 그렇게 되면 다른 조인 알고리즘을 선택하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;hash-vs-sort-merge&quot;&gt;Hash vs Sort Merge&lt;/h2&gt;
&lt;p&gt;이제 Hash 조인과 Sort Merge 조인 중 어떤 알고리즘이 선택되는지에 대해 알아보자. 아래 4가지를 핵심으로 데이터베이스 옵티마이저가 어떤게 좋은 쿼리 성능을 낼지 판단하게 된다.&lt;/p&gt;

&lt;h3 id=&quot;1-인덱스&quot;&gt;1. 인덱스&lt;/h3&gt;
&lt;p&gt;양쪽 테이블이 Join하는 필드에 인덱스가 설정돼있다면 Sort Merge Join이 유리하다. 이름부터 정렬이 붙어있는것만봐도 알수 있듯이 양쪽테이블을 정렬하는 것이 Sort Merge Join의 시작이다. 그런데 &lt;strong&gt;정렬을 진행할 조인키에 이미 인덱스가 설정되어있다면 이미 정렬이 돼있는 것이기때문에 정렬 과정이 생략된다.&lt;/strong&gt; 정렬 작업이 제일 큰 리소스를 소모하는 단계였기때문에 Hash Join보다 큰 성능을 낼수 있게 된다.
둘다 O(N+M)의 시간복잡도를 가졌는데 Sort Merge Join은 기초작업(정렬)이 사라진 반면 Hash Join은 여전히 기초 작업(해시 테이블을 만드는 작업)이 필요하다. 그러므로 성능상 우위에 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-데이터-분포&quot;&gt;2. 데이터 분포&lt;/h3&gt;
&lt;p&gt;테이블끼리 조인될 때 모두 one-to-one으로 하나씩 매칭돼서 조인되는 것이 아니라 ManyToOne, ManyToMany와 같이 몇몇 인기있는 행에만 여러 조인이 생길때가 많다. (학생과 강의 테이블이 있다고 하면 특정 인기 강의를 조인하는 학생 데이터가 훨씬 많다.) 이러한 상황에 해시테이블을 만들게 되면 같은 해시 테이블 키에 여러 데이터가 들어가버린다.(해시테이블의 값은 일반적으로 바구니(bucket) 형태이다. 여러개의 값이 들어갈수 있다는 의미.) 해시테이블에서는 key에 대해 값이 너무 여러개가 돼버리면 해시키로 값을 찾은 뒤에도 그 값들에서 또 Join key 비교를 해야한다. 이렇듯 해시충돌이 많이 발생해버리면 해시 테이블을 만들어 key로 빠르게 value를 찾으려는 의미가 사라져버린다.&lt;/p&gt;

&lt;h3 id=&quot;3-양쪽-테이블의-데이터-양&quot;&gt;3. 양쪽 테이블의 데이터 양&lt;/h3&gt;
&lt;p&gt;Hash Join은 양쪽 테이블 중 크기가 작은 것을 이용해 해시테이블을 만드는데 크기가 둘 다 크다면 메모리 이용율이 많아져 좋지 않다. 그리고 해시 데이터가 많아질수록 해시충돌할 확률이 커지므로 성능이 저하된다. 양쪽 테이블의 크기가 크다면 메모리 사용율이 적은 Sort Merge Join이 유리하다.&lt;/p&gt;

&lt;h3 id=&quot;4-이용가능한-메모리&quot;&gt;4. 이용가능한 메모리&lt;/h3&gt;
&lt;p&gt;위에서 계속해서 Hash Join은 메모리에 해시테이블을 만든다고 했다. 그러니 당연하게도 Sort Merge Join보다 메모리 이용이 커지니 메모리가 부족한 환경에서는 불리하다.&lt;/p&gt;

&lt;h3 id=&quot;5-join-key의-크기-복잡성&quot;&gt;5. Join key의 크기, 복잡성&lt;/h3&gt;
&lt;p&gt;Join에 이용되는 Key가 너무 길거나 복잡하면 비교 작업에 시간이 더 걸릴 수 있다. 정렬 또한 비교작업이기 때문에 Sort Merge Join에는 취약하다. 반면에 Hash는 key의 복잡성에 그리 큰 영향을 받지 않는다. 그리고 해시함수의 결과값은 인풋의 복잡성,길이에 아무 상관없이 고정된 길이로 변환한다. 그러므로 복잡한 Join key를 가지고 비교하는 과정이 덜한 Hash join이 다른 알고리즘에 비해 유리하다.&lt;/p&gt;

&lt;p&gt;위 5가지 +a로 데이터베이스 옵티마이저가 무엇이 좋을지 판단해서 쿼리를 실행하게 된다.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Jan 2023 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//join-algorithms-2</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//join-algorithms-2</guid>
        
        <category>database</category>
        
        <category>join</category>
        
        
      </item>
    
      <item>
        <title>Join 알고리즘 대표적 3가지</title>
        <description>&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;(현재글) 1. Join 알고리즘의 종류&lt;/u&gt; &lt;br /&gt;
&lt;a href=&quot;https://moonqqqq.github.io/join-algorithms-1&quot;&gt;2. Join 알고리즘 최적화&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
Join을 포함한 쿼리가 실행될 때 데이터베이스 프로세서는 지금 디비 상황에 맞는 join 알고리즘을 선택해야 한다. 대표적인 3가지를 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;nested-loop-join&quot;&gt;Nested Loop Join&lt;/h1&gt;
&lt;p&gt;이름 그대로 중첩 loop 방식으로 조건에 맞는 데이터를 찾는다. 중첩 for문이라고 생각하면 된다.
첫번째 테이블에서 데이터를 하나 선택하고 두번째 테이블을 선회하면서 둘의 조인키를 확인하며 조건이 맞는지 확인한다.
User와 School 테이블이 있고 서로가 userId로 조인된 상태라면 아래 처럼 작동한다.&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫번째 Loop&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;schools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두번째 Loop&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;schoolId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두 테이블의 데이터를 가져왔으니 조인 조건 확인.&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;pushToResultArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;school&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 조건이 맞다면 결과에 추가.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 복잡도가 n제곱이라서 성능상 좋지않은거냐고 할수 있다. 맞다. 그래서 많은 양의 데이터를 검색할때는 성능이 좋지않다.
그런데 대부분의 쿼리에는 &lt;strong&gt;where절&lt;/strong&gt;이 있기때문에 최대한 loop에 돌아가는 범위를 줄이게 된다. where로 데이터 범위를 줄일수 없다면 데이터베이스가 알아서 다른 join 알고리즘으로 변경하여 성능을 최적화한다.&lt;/p&gt;

&lt;h1 id=&quot;hash-join&quot;&gt;Hash Join&lt;/h1&gt;
&lt;p&gt;Hash Join은 두 테이블이 조인하는 특정 값을 이용한다. 둘이 같은 값을 가지고 있기 때문에(user, school이라면 user가 schoolId를 가지므로 같은 값을 가짐.) &lt;strong&gt;같은 해시 함수를 실행하면 같은 응답값이 나오는 걸 이용하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;먼저 해시 테이블을 만든다. 조인된 두 테이블 중 사이즈가 작은 테이블을 찾는다. 그리고 작은 사이즈의 테이블로 해시테이블을 만든다. &lt;strong&gt;해시 테이블&lt;/strong&gt;의 키는 조인에 이용되는 값을 해시 함수 실행시켜 얻은 값이다. &lt;strong&gt;해시 테이블의 값&lt;/strong&gt;은 해당 열이다. 해당 열의 일부분이 될수도 있고 전부가 될수도 있다. 혹은 해당 열의 메모리 주소값일수도 있다.(메모리 주소로 값을 저장하면 추후에 메모리 주소로 다시 접근하여 데이터를 얻어야하는 단점이 있다.)&lt;/p&gt;

&lt;p&gt;데이터가 아래와 같다면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/writing-images/usertable.png&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;/img/writing-images/schooltable.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 School테이블이 사이즈가 더 작기때문에 School 테이블을 이용하여 해시 테이블을 만든다. User와 School 테이블은 schoolId로 서로 조인하고 있기 때문에 School.id를 해시함수 실행시켜 키 값을 설정한다. 그리고 해시 테이블의 값으로는 해당 열 데이터의 일부를 저장한다. 예시에서는 school 데이터의 ID를 저장한다.&lt;/p&gt;

&lt;p&gt;‘aaa1’은 1을 해시함수 돌린 값, ‘aaa2’는 2를 해시함수 돌린값이라고 생각하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/writing-images/hashtable.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 나머지 테이블(크기가 좀더 큰 테이블: User)&lt;/strong&gt;에서 작업을 시작한다. User 테이블을 순회하여 School과의 조인을 나타내는 값을 해시 함수 실행시킨다. 해시 함수 실행 결과 값을 해시 테이블과 매칭해서 같은 값이 있으면 해당 테이블과 결합시킨다. 그리고 결과 목록에 추가한다. User 테이블에서 순회를 마치면 결과 목록이 완성된다.&lt;/p&gt;

&lt;p&gt;대략 코드로 표현하면 이렇다.&lt;/p&gt;
&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;findSmallerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Schools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;biggerTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Schools&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hashTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createHashTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;smallerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eachRow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;biggerTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;joinedTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;findMatchingDataFromOtherTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hashFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;eachRow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;joinKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pushToJoinResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;joinedTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eachRwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;merge-join&quot;&gt;Merge Join&lt;/h1&gt;

&lt;p&gt;Merge 조인은 조인되는 두 테이블을 각자 조인키 값을 기준으로 정렬시킨다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;scholl_Id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOOLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
위 값으로 Merge 조인을 한다면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;개별 테이블이 공유하는 조인키로 정렬된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래를 보면 USERS가 school_id로 정렬된 걸 확인할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(School id로 정렬된 두 테이블)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이제 두 테이블을 맨위 부터 비교하며 조인 키값이 같은 데이터들을 찾는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;첫번째-비교&quot;&gt;첫번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;같은 키로 정렬된 상태이므로 바로바로 같은 조인키 값을 가진 데이터들을 찾을수 있다. 
같은 포인터 위치의 데이터끼리 조인키를 비교한다. &lt;strong&gt;값이 같다면 둘의 데이터를 병합하여 결과 데이터에 추가한다.
그리고 두 테이블 모두 포인터를 다음번 데이터로 옮긴다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;두번째-비교&quot;&gt;두번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;두번째 비교에서도 바로 포인터에 있는 데이터들이 조인키가 같다. 결과 목록에 병합하여 추가한다.&lt;/p&gt;

&lt;h4 id=&quot;세번째-비교&quot;&gt;세번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;세번째에 와서야 포인터에있는 값들이 조인키가 맞지않다. 이럴 때는 조인키를 비교하여 작은 값을 가진쪽에서 포인터를 다음으로 옮긴다.&lt;/p&gt;

&lt;h4 id=&quot;네번째-비교&quot;&gt;네번째 비교&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USERS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;school_id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;lee&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;choi&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;kim&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;lim&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SCHOLLS&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;pointer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;seoul&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;busan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;lala&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이번에도 포인터들의 조인값을 비교해봤지만 같지 않다. 그런데 이번에는 조인값이 작은 쪽에서 더이상 다음 값으로 옮길수가 없다. 이러면 더이상 매칭할 데이터가 없는 것이기 때문에 탐색 과정이 끝난다. 그리고 병합된 데이터를 리턴한다.&lt;/p&gt;

&lt;p&gt;이때 Join 방식에 따라(inner, left, right, full etc..) 매칭되지않은 데이터들에 대해 null을 한쪽 테이블 데이터는 null을 설정해서 결과값에 추가할지 두 테이블 데이터 모두 보여주지않을지 결정하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;다음 글에서는 이 3가지 알고리즘의 최적화에 대해 알아보자.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Jan 2023 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000//join-algorithms-1</link>
        <guid isPermaLink="true">http://0.0.0.0:4000//join-algorithms-1</guid>
        
        <category>database</category>
        
        <category>join</category>
        
        
      </item>
    
  </channel>
</rss>