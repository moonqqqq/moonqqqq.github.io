<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>김문규블로그</title>
  <meta name="description" content="Node.js 백엔드 개발자">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="//">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	      <a href="//about" title=""></a>
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  <a href="https://github.com/moonqqqq" aria-label="Homepage" class="footer-octicon" title="GitHub">
    <svg aria-hidden="true" class="octicon octicon-mark-github" height="20" version="1.1" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
</svg>
</a>

	</div>
  
  <!-- Nav footer -->
	
	  <footer>
	
	<span>version 1.0.0</span>

</footer>
	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">  
      <a href="//">
        <h1>
          <span>김문규블로그</span>
        </h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
	    
	      
	    
	      
	        <a href="/about" title=""></a>
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
      
      <!-- Nav links -->
	    <a href="https://github.com/moonqqqq" aria-label="Homepage" class="footer-octicon" title="GitHub">
    <svg aria-hidden="true" class="octicon octicon-mark-github" height="20" version="1.1" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
</svg>
</a>

    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<!-- Posts -->
<ul id="posts">

	

	  <li class="post">
	  	<h2><a href="/stream-and-dirty-write">딥리서치 스트림 - 재실행 보장과 Dirty Write</a></h2>
      <time datetime="2025-08-01T00:00:00-05:00" class="by-line"> <i>01 Aug 2025</i> </time>
	  	<p>LLM 딥리서치 기능은 장시간 Stream으로 응답을 전달해줘야하면서도 무조건 성공해야하는 작업에 속한다. 그래서 Queue로 작업들을 안전하게 보관하면서 작업이 실패했을 때는 성공할때까지 재실행을 해야한다. UI적으로도 오래걸린다는걸 표현하고 있기때문에 빠르게 응답을 할 필요도 딱히 없다. 하지만 여기서 문제는 “어떻게든 성공해야한다”라는 측면에서 발생한다. Queue를 통해 재실행을 관리하다보면 하나의 job 동시에 여러군데서 실행되는 일이 발생한다....</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/sse-and-observable-limitation-on-memory">Node.js의 스트림 배압 처리 고도화 (Observable의 한계점)</a></h2>
      <time datetime="2025-05-10T00:00:00-05:00" class="by-line"> <i>10 May 2025</i> </time>
	  	<p>LLM 응답 스트리밍 서버가 OOM(Out of memory)으로인해 꺼져버리는 현상이 간간히 로그에 찍혀있었다. 기존 서버는 llm 응답값을 sse로 스트리밍해주는 서버다. 단순히 @Sse 데코레이터에 Observable을 리턴하는 형식으로 구현되어있다. 단순화하면 아래 구조로 표현할 수 있다. Stream API server –(subscribe)–&gt; Redis pubsub &lt;–(push)– llm 워커에서 llm 응답값 전달 @Sse가 알아서 헤더 설정도 해주고 응답값도...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/kafka-producer-options">카프카 프로듀서 필수 설정값</a></h2>
      <time datetime="2025-01-08T00:00:00-06:00" class="by-line"> <i>08 Jan 2025</i> </time>
	  	<p>기본적인 프로듀서 설정값들을 정리한 글이다. 실무에서 쓰일만한 설정값들을 대충 훑어보고 개념으로 넘어가자. 마이크로서비스에서 카프카를 이용할 때는 속도가 중요하다. 그럴 때는 아래와 같은 설정이 필요하다. 1 2 3 4 5 6 7 // 마이크로서비스 batch.size=32768 linger.ms=5 acks=1 max.in.flight.requests.per.connection=5 enable.idempotence=true compression.type=snappy 반면에 로그를 처리하는 용도로 카프카를 이용한다면 아래와 같은 설정이면 충분하다. 1...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/cold-data">Cold Data - 거의 이용되지않는 데이터 관리</a></h2>
      <time datetime="2024-03-01T00:00:00-06:00" class="by-line"> <i>01 Mar 2024</i> </time>
	  	<p>거의 이용되지않는 데이터 관리 [오래된 데이터 저장 - append-only 데이터 처리] 서비스가 커지면서 데이터가 나날이 늘어간다. 일단은 데이터베이스 샤딩으로 해결하려고 하지만 한계가 명확하다. 그리고 제일 중요한 비용이 너무 커져버린다. 이럴 때 데이터를 어떻게 저장하고 이용할지에 대해 정리하는 글이다. 우리가 신경써야할 데이터의 종류는 크게 두가지로 나뉜다. 1.일년에 몇번 간간히 검색을 하긴...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/temporal-tips">Temporal.io 개발/운영 팁</a></h2>
      <time datetime="2024-02-25T00:00:00-06:00" class="by-line"> <i>25 Feb 2024</i> </time>
	  	<p>데이터 오케스트레이션 툴로 Temporal를 운영하면서 얻은 팁들을 정리한다. Temporal의 기본적인 구조는 알고 있어야 이해가 가능한 글이다. Temporal의 목적은 작기적으로 실행되는 프로세스를 안정적으로 완료하는 것이다. 이를 중심으로 팁들이 구성된다. 1. 엑티비티는 최대한 작게 만든다. 하나의 일만 하게 한다. Temporal은 “장기적으로 실행되는 프로세스를 안정적으로 완료”하는게 목적이다보니 재실행 프로세스가 정말 안정적이다. 어떠한 장애가...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/from-the-libuv-server-series-2">API 서버가 데이터를 받기까지 [epoll] - 서버가 작동하는 흐름 2</a></h2>
      <time datetime="2024-01-23T00:00:00-06:00" class="by-line"> <i>23 Jan 2024</i> </time>
	  	<p>시리즈 목차 1.서버가 데이터를 받기까지 [운영체제에서] (현재글) 2.서버가 데이터를 받기까지 [libuv - epoll] 3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. 4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS 이전 단계에서 데이터가 “receive socket buffer”에 도착했다. 이제 Node.js 서버가 데이터를 가져와서 처리해야한다. 데이터를 가져오는 일을...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/before-arriving-server-server-series-1">API 서버가 데이터를 받기까지 (운영체제에서) - 서버가 작동하는 흐름 1</a></h2>
      <time datetime="2024-01-02T00:00:00-06:00" class="by-line"> <i>02 Jan 2024</i> </time>
	  	<p>시리즈 목차 (현재글) 1.서버가 데이터를 받기까지 [운영체제에서] 2.서버가 데이터를 받기까지 [libuv] 3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. 4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS API 서버가 데이터를 받기까지. 우리가 만든 Node.js 서버가 데이터를 받기위해선 포트 번호(ex. 3000, 8080)와 바인딩되어야한다. 그래야만 운영체제가 node.js...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/mvcc">Postgres 동시성 [기본락과 MVCC]</a></h2>
      <time datetime="2023-12-02T00:00:00-06:00" class="by-line"> <i>02 Dec 2023</i> </time>
	  	<p>데이터베이스단에서 동시성 확보는 디비 자체적으로 해주는 것과 프로그래머가 직접 코드로 짜야하는 걸로 나뉜다. 그중 데이터베이스에서 제공해주는 부분을 알아본다. “1. 기본적인 잠금(shared/exclusive lock)”과 “2. Isolation level 구현(MVCC)” 이 두가지가 데이터베이스에서 이미 완성시켜둔 동시성 도구들이다. 이 둘의 조합으로 기본적인 동시성 제어를 구성한다. 1. 기본 잠금 - Shared Lock, Exclusive Lock 모든 데이터베이스에서는...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/socketio-non-stop-deployment">채팅서버 무중단 배포(Socket.io)</a></h2>
      <time datetime="2023-07-23T00:00:00-05:00" class="by-line"> <i>23 Jul 2023</i> </time>
	  	<p>채팅 서버 무중단 배포 방식을 정리하고 가자. BlueGreen, Canary과 같은 배포 방식에 관련된 글이라기보다는 무중단 배포에 있어 채팅 서버의 어떤 점들을 유의해야하는지에 대한 글이겠다. (Socket.io를 기준으로) Socket 배포에 있어서 중요한 건 “client-server간의 관련 데이터 관리”, “client-server connection 관리”이 두가지가 되겠다. socket.io 관련 데이터 관리. socket.io에서는 실시간 통신을 위해 필요한 데이터들이...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/dependnecy-manage-on-nestjs">Nest.js 모듈 구조 관리 (Avoiding circular dependency)</a></h2>
      <time datetime="2023-06-30T00:00:00-05:00" class="by-line"> <i>30 Jun 2023</i> </time>
	  	<p>어떤 아키텍쳐를 쓰던 DI(dependency injection)는 대부분 이용된다. Nest.js의 기본 구조도 그렇다. 그런데 DI로 개발하다보면 의존성이 꼬이는 일이 발생하는 경우가 있다. 대부분이 circular dependency로 나타난다. 이 때 lazy loading을 이용해서 circular dependency 발생 없이 개발할수도 있지만 상호의존은 최악의 구조이기 때문에 최대한 불가피한 경우에만 써야한다. 내가 관리하는 프로젝트들에서 상호 의존을 피하기 위한...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/join-algorithms-2">Join 알고리즘 특징/최적화</a></h2>
      <time datetime="2023-01-06T00:00:00-06:00" class="by-line"> <i>06 Jan 2023</i> </time>
	  	<p>시리즈 목차 1. Join 알고리즘의 종류 (현재글) 2. Join 알고리즘 최적화 3가지 조인 비교 3가지 조인 알고리즘이 어떤 상황에 선택되는지(유리한지) 알아보자. 일단은 시간복잡도부터 따져보면. Nested Loop은 O(N*M), Hash와 Sort-Merge는 O(N+M)이다. 조인 알고리즘은 WHERE문으로 필터링된 데이터의 갯수에 따라 첫번째로 갈린다. WHERE문으로 필터링이 많이돼서 Join할 데이터가 적다면 Nested Loop 조인을 이용한다. WHERE문으로...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/join-algorithms-1">Join 알고리즘 대표적 3가지</a></h2>
      <time datetime="2023-01-03T00:00:00-06:00" class="by-line"> <i>03 Jan 2023</i> </time>
	  	<p>시리즈 목차 (현재글) 1. Join 알고리즘의 종류 2. Join 알고리즘 최적화 Join을 포함한 쿼리가 실행될 때 데이터베이스 프로세서는 지금 디비 상황에 맞는 join 알고리즘을 선택해야 한다. 대표적인 3가지를 알아보자. Nested Loop Join 이름 그대로 중첩 loop 방식으로 조건에 맞는 데이터를 찾는다. 중첩 for문이라고 생각하면 된다. 첫번째 테이블에서 데이터를 하나 선택하고...</p>
	  </li>

    

</ul>


	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2017 - Monochrome</span></footer>


	    <!-- Script -->
      <script src="/js/main.js"></script>	


	</div>
</body>
</html>
