<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>김문규블로그</title>
  <meta name="description" content="Node.js 백엔드 개발자">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="//">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	      <a href="//about" title=""></a>
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  <a href="https://github.com/moonqqqq" aria-label="Homepage" class="footer-octicon" title="GitHub">
    <svg aria-hidden="true" class="octicon octicon-mark-github" height="20" version="1.1" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
</svg>
</a>

	</div>
  
  <!-- Nav footer -->
	
	  <footer>
	
	<span>version 1.0.0</span>

</footer>
	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">  
      <a href="//">
        <h1>
          <span>김문규블로그</span>
        </h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
	    
	      
	    
	      
	        <a href="/about" title=""></a>
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
      
      <!-- Nav links -->
	    <a href="https://github.com/moonqqqq" aria-label="Homepage" class="footer-octicon" title="GitHub">
    <svg aria-hidden="true" class="octicon octicon-mark-github" height="20" version="1.1" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
</svg>
</a>

    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<!-- Posts -->
<ul id="posts">

	

	  <li class="post">
	  	<h2><a href="/sse-and-observable-limitation-on-memory">Node.js의 스트림 배압 처리 고도화 (Observable의 한계점)</a></h2>
      <time datetime="2025-05-10T00:00:00-05:00" class="by-line"> <i>10 May 2025</i> </time>
	  	<p>LLM 응답 스트리밍 서버가 OOM(Out of memory)으로인해 꺼져버리는 현상이 간간히 로그에 찍혀있었다. 기존 서버는 llm 응답값을 sse로 스트리밍해주는 서버다. 단순히 @Sse 데코레이터에 Observable을 리턴하는 형식으로 구현되어있다. 단순화하면 아래 구조로 표현할 수 있다. Stream API server –(subscribe)–&gt; Redis pubsub &lt;–(push)– llm 워커에서 llm 응답값 전달 @Sse가 알아서 헤더 설정도 해주고 응답값도...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/kafka-producer-options">카프카 프로듀서 필수 설정값</a></h2>
      <time datetime="2025-01-08T00:00:00-06:00" class="by-line"> <i>08 Jan 2025</i> </time>
	  	<p>기본적인 프로듀서 설정값들을 정리한 글이다. 실무에서 쓰일만한 설정값들을 대충 훑어보고 개념으로 넘어가자. 마이크로서비스에서 카프카를 이용할 때는 속도가 중요하다. 그럴 때는 아래와 같은 설정이 필요하다. 1 2 3 4 5 6 7 // 마이크로서비스 batch.size=32768 linger.ms=5 acks=1 max.in.flight.requests.per.connection=5 enable.idempotence=true compression.type=snappy 반면에 로그를 처리하는 용도로 카프카를 이용한다면 아래와 같은 설정이면 충분하다. 1...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/cold-data">Cold Data - 거의 이용되지않는 데이터 관리</a></h2>
      <time datetime="2024-03-01T00:00:00-06:00" class="by-line"> <i>01 Mar 2024</i> </time>
	  	<p>거의 이용되지않는 데이터 관리 [오래된 데이터 저장 - append-only 데이터 처리] 서비스가 커지면서 데이터가 나날이 늘어간다. 일단은 데이터베이스 샤딩으로 해결하려고 하지만 한계가 명확하다. 그리고 제일 중요한 비용이 너무 커져버린다. 이럴 때 데이터를 어떻게 저장하고 이용할지에 대해 정리하는 글이다. 우리가 신경써야할 데이터의 종류는 크게 두가지로 나뉜다. 1.일년에 몇번 간간히 검색을 하긴...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/temporal-tips">Temporal.io 개발/운영 팁</a></h2>
      <time datetime="2024-02-25T00:00:00-06:00" class="by-line"> <i>25 Feb 2024</i> </time>
	  	<p>데이터 오케스트레이션 툴로 Temporal를 운영하면서 얻은 팁들을 정리한다. Temporal의 기본적인 구조는 알고 있어야 이해가 가능한 글이다. Temporal의 목적은 작기적으로 실행되는 프로세스를 안정적으로 완료하는 것이다. 이를 중심으로 팁들이 구성된다. 1. 엑티비티는 최대한 작게 만든다. 하나의 일만 하게 한다. Temporal은 “장기적으로 실행되는 프로세스를 안정적으로 완료”하는게 목적이다보니 재실행 프로세스가 정말 안정적이다. 어떠한 장애가...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/from-the-libuv-server-series-2">API 서버가 데이터를 받기까지 [epoll] - 서버가 작동하는 흐름 2</a></h2>
      <time datetime="2024-01-23T00:00:00-06:00" class="by-line"> <i>23 Jan 2024</i> </time>
	  	<p>시리즈 목차 1.서버가 데이터를 받기까지 [운영체제에서] (현재글) 2.서버가 데이터를 받기까지 [libuv - epoll] 3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. 4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS 이전 단계에서 데이터가 “receive socket buffer”에 도착했다. 이제 Node.js 서버가 데이터를 가져와서 처리해야한다. 데이터를 가져오는 일을...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/before-arriving-server-server-series-1">API 서버가 데이터를 받기까지 (운영체제에서) - 서버가 작동하는 흐름 1</a></h2>
      <time datetime="2024-01-02T00:00:00-06:00" class="by-line"> <i>02 Jan 2024</i> </time>
	  	<p>시리즈 목차 (현재글) 1.서버가 데이터를 받기까지 [운영체제에서] 2.서버가 데이터를 받기까지 [libuv] 3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. 4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS API 서버가 데이터를 받기까지. 우리가 만든 Node.js 서버가 데이터를 받기위해선 포트 번호(ex. 3000, 8080)와 바인딩되어야한다. 그래야만 운영체제가 node.js...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/mvcc">Postgres 동시성 [기본락과 MVCC]</a></h2>
      <time datetime="2023-12-02T00:00:00-06:00" class="by-line"> <i>02 Dec 2023</i> </time>
	  	<p>데이터베이스단에서 동시성 확보는 디비 자체적으로 해주는 것과 프로그래머가 직접 코드로 짜야하는 걸로 나뉜다. 그중 데이터베이스에서 제공해주는 부분을 알아본다. “1. 기본적인 잠금(shared/exclusive lock)”과 “2. Isolation level 구현(MVCC)” 이 두가지가 데이터베이스에서 이미 완성시켜둔 동시성 도구들이다. 이 둘의 조합으로 기본적인 동시성 제어를 구성한다. 1. 기본 잠금 - Shared Lock, Exclusive Lock 모든 데이터베이스에서는...</p>
	  </li>

    

	  <li class="post">
	  	<h2><a href="/socketio-non-stop-deployment">채팅서버 무중단 배포(Socket.io)</a></h2>
      <time datetime="2023-07-23T00:00:00-05:00" class="by-line"> <i>23 Jul 2023</i> </time>
	  	<p>채팅 서버 무중단 배포 방식을 정리하고 가자. BlueGreen, Canary과 같은 배포 방식에 관련된 글이라기보다는 무중단 배포에 있어 채팅 서버의 어떤 점들을 유의해야하는지에 대한 글이겠다. (Socket.io를 기준으로) Socket 배포에 있어서 중요한 건 “client-server간의 관련 데이터 관리”, “client-server connection 관리”이 두가지가 되겠다. socket.io 관련 데이터 관리. socket.io에서는 실시간 통신을 위해 필요한 데이터들이...</p>
	  </li>

    

</ul>


	  </main>
		
		  <!-- Pagination links -->
      
        <div class="pagination">
          
            <span class="page-item">&laquo;</span>
          
        
          
            
              <span class="page-item">1</span>
            
          
            
              <a href="/page2/" class="page-item">2</a>
            
          
        
          
            <a href="/page2/" class="page-item">&raquo;</a>
          
        </div>
        

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2017 - Monochrome</span></footer>


	    <!-- Script -->
      <script src="/js/main.js"></script>	


	</div>
</body>
</html>
