<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>김문규블로그</title>
 <link href="http://0.0.0.0:4000/atom.xml" rel="self"/>
 <id>http://0.0.0.0:4000</id>
 <updated>2026-02-10T22:33:00-06:00</updated>
 <author>
   <name>moonq kim</name>
   <uri>https://moonqqqq.github.io</uri>
   <email>make.abundant@gmail.com</email>
 </author>

 

 <entry>
   <title>Node.js의 스트림 배압 처리 고도화 (Observable의 한계점)</title>
   <link href="http://0.0.0.0:4000/sse-and-observable-limitation-on-memory"/>
   <id>http://0.0.0.0:4000/sse-and-observable-limitation-on-memory</id>
   <updated>2025-05-10T00:00:00-05:00</updated>
   <content type="html">&lt;p&gt;LLM 응답 스트리밍 서버가 OOM(Out of memory)으로인해 꺼져버리는 현상이 간간히 로그에 찍혀있었다.&lt;/p&gt; &lt;p&gt;기존 서버는 llm 응답값을 sse로 스트리밍해주는 서버다. 단순히 @Sse 데코레이터에 Observable을 리턴하는 형식으로 구현되어있다. 단순화하면 아래 구조로 표현할 수 있다.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Stream API server –(subscribe)–&amp;gt; Redis pubsub &amp;lt;–(push)– llm 워커에서 llm 응답값 전달&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;@Sse가 알아서 헤더 설정도...</content>
 </entry>

 

 <entry>
   <title>카프카 프로듀서 필수 설정값</title>
   <link href="http://0.0.0.0:4000/kafka-producer-options"/>
   <id>http://0.0.0.0:4000/kafka-producer-options</id>
   <updated>2025-01-08T00:00:00-06:00</updated>
   <content type="html">&lt;p&gt;기본적인 프로듀서 설정값들을 정리한 글이다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;실무에서 쓰일만한 설정값들을 대충 훑어보고 개념으로 넘어가자.&lt;/p&gt; &lt;p&gt;마이크로서비스에서 카프카를 이용할 때는 속도가 중요하다. 그럴 때는 아래와 같은 설정이 필요하다.&lt;/p&gt; &lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1 2 3 4 5 6 7 &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 마이크로서비스&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span...</content>
 </entry>

 

 <entry>
   <title>Cold Data - 거의 이용되지않는 데이터 관리</title>
   <link href="http://0.0.0.0:4000/cold-data"/>
   <id>http://0.0.0.0:4000/cold-data</id>
   <updated>2024-03-01T00:00:00-06:00</updated>
   <content type="html">&lt;p&gt;거의 이용되지않는 데이터 관리 [오래된 데이터 저장 - append-only 데이터 처리]&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;서비스가 커지면서 데이터가 나날이 늘어간다. 일단은 데이터베이스 샤딩으로 해결하려고 하지만 한계가 명확하다. 그리고 제일 중요한 비용이 너무 커져버린다. 이럴 때 데이터를 어떻게 저장하고 이용할지에 대해 정리하는 글이다.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;우리가 신경써야할 데이터의 종류는 크게 두가지로 나뉜다.&lt;/p&gt; &lt;ol&gt; &lt;li&gt;1.일년에 몇번...</content>
 </entry>

 

 <entry>
   <title>Temporal.io 개발/운영 팁</title>
   <link href="http://0.0.0.0:4000/temporal-tips"/>
   <id>http://0.0.0.0:4000/temporal-tips</id>
   <updated>2024-02-25T00:00:00-06:00</updated>
   <content type="html">&lt;p&gt;데이터 오케스트레이션 툴로 Temporal를 운영하면서 얻은 팁들을 정리한다. Temporal의 기본적인 구조는 알고 있어야 이해가 가능한 글이다.&lt;/p&gt; &lt;p&gt;Temporal의 목적은 작기적으로 실행되는 프로세스를 안정적으로 완료하는 것이다. 이를 중심으로 팁들이 구성된다.&lt;/p&gt; &lt;h3 id=&quot;1-엑티비티는-최대한-작게-만든다-하나의-일만-하게-한다&quot;&gt;1. 엑티비티는 최대한 작게 만든다. 하나의 일만 하게 한다.&lt;/h3&gt; &lt;p&gt;Temporal은 “장기적으로 실행되는 프로세스를 안정적으로 완료”하는게 목적이다보니 재실행 프로세스가 정말 안정적이다. 어떠한...</content>
 </entry>

 

 <entry>
   <title>서버가 데이터를 받기까지 [epoll] - 서버가 작동하는 흐름 2</title>
   <link href="http://0.0.0.0:4000/from-the-libuv-server-series-2"/>
   <id>http://0.0.0.0:4000/from-the-libuv-server-series-2</id>
   <updated>2024-01-23T00:00:00-06:00</updated>
   <content type="html">&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt; &lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;1.서버가 데이터를 받기까지 [운영체제에서]&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;&lt;u&gt;(현재글) 2.서버가 데이터를 받기까지 [libuv - epoll]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt; 3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt; 4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;&lt;br /&gt;&lt;/p&gt; &lt;p&gt;이전 단계에서 데이터가...</content>
 </entry>

 

 <entry>
   <title>API 서버가 데이터를 받기까지 (운영체제에서) - 서버가 작동하는 흐름 1</title>
   <link href="http://0.0.0.0:4000/before-arriving-server-server-series-1"/>
   <id>http://0.0.0.0:4000/before-arriving-server-server-series-1</id>
   <updated>2024-01-02T00:00:00-06:00</updated>
   <content type="html">&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt; &lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/before-arriving-server-server-series-1&quot;&gt;&lt;u&gt;(현재글) 1.서버가 데이터를 받기까지 [운영체제에서]&lt;/u&gt;&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;https://moonqqqq.github.io/from-the-libuv-server-series-2&quot;&gt;2.서버가 데이터를 받기까지 [libuv]&lt;/a&gt; &lt;br /&gt; 3.서버가 받은 데이터가 어떻게 처리되는지. Node.js만의 방식이 어떤지 정리한다. &lt;br /&gt; 4.Node.js만의 방식을 하나하나 조금 더 디테일하게 - Event loop, Libuv, V8, JS&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;&lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;api-서버가-데이터를-받기까지&quot;&gt;API 서버가 데이터를 받기까지.&lt;/h1&gt;...</content>
 </entry>

 

 <entry>
   <title>백엔드 동시성 - 1. Postgres 가시성</title>
   <link href="http://0.0.0.0:4000/mvcc"/>
   <id>http://0.0.0.0:4000/mvcc</id>
   <updated>2023-12-02T00:00:00-06:00</updated>
   <content type="html">&lt;p&gt;데이터베이스단에서 동시성 확보는 디비 자체적으로 해주는 것과 프로그래머가 직접 코드로 짜야하는 걸로 나뉜다. 그중 데이터베이스에서 제공해주는 부분을 알아본다.&lt;/p&gt; &lt;p&gt;“1. 기본적인 잠금(shared/exclusive lock)”과 “2. Isolation level 구현(MVCC)” 이 두가지가 데이터베이스에서 이미 완성시켜둔 동시성 도구들이다. 이 둘의 조합으로 기본적인 동시성 제어를 구성한다.&lt;/p&gt; &lt;h2 id=&quot;1-기본-잠금---shared-lock-exclusive-lock&quot;&gt;1. 기본 잠금 - Shared Lock, Exclusive Lock&lt;/h2&gt; &lt;p&gt;모든...</content>
 </entry>

 

 <entry>
   <title>Socket.io 무중단 배포</title>
   <link href="http://0.0.0.0:4000/socketio-non-stop-deployment"/>
   <id>http://0.0.0.0:4000/socketio-non-stop-deployment</id>
   <updated>2023-07-23T00:00:00-05:00</updated>
   <content type="html">&lt;p&gt;채팅 서버 무중단 배포 방식을 정리하고 가자.&lt;/p&gt; &lt;p&gt;BlueGreen, Canary과 같은 배포 방식에 관련된 글이라기보다는 무중단 배포에 있어 채팅 서버의 어떤 점들을 유의해야하는지에 대한 글이겠다. (Socket.io를 기준으로)&lt;/p&gt; &lt;p&gt;Socket 배포에 있어서 중요한 건 “client-server간의 관련 데이터 관리”, “client-server connection 관리”이 두가지가 되겠다.&lt;/p&gt; &lt;h2 id=&quot;socketio-관련-데이터-관리&quot;&gt;socket.io 관련 데이터 관리.&lt;/h2&gt; &lt;p&gt;socket.io에서는 실시간 통신을 위해 필요한...</content>
 </entry>

 

 <entry>
   <title>Nest.js 모듈 구조 관리 (Avoiding circular dependency)</title>
   <link href="http://0.0.0.0:4000/dependnecy-manage-on-nestjs"/>
   <id>http://0.0.0.0:4000/dependnecy-manage-on-nestjs</id>
   <updated>2023-06-30T00:00:00-05:00</updated>
   <content type="html">&lt;p&gt;어떤 아키텍쳐를 쓰던 DI(dependency injection)는 대부분 이용된다. Nest.js의 기본 구조도 그렇다. 그런데 DI로 개발하다보면 의존성이 꼬이는 일이 발생하는 경우가 있다. 대부분이 &lt;strong&gt;circular dependency&lt;/strong&gt;로 나타난다. 이 때 &lt;em&gt;lazy loading&lt;/em&gt;을 이용해서 circular dependency 발생 없이 개발할수도 있지만 상호의존은 최악의 구조이기 때문에 최대한 불가피한 경우에만 써야한다.&lt;/p&gt; &lt;p&gt;내가 관리하는 프로젝트들에서 상호 의존을 피하기 위한...</content>
 </entry>

 

 <entry>
   <title>Join 알고리즘 대표적 3가지 특징/최적화</title>
   <link href="http://0.0.0.0:4000/join-algorithms-2"/>
   <id>http://0.0.0.0:4000/join-algorithms-2</id>
   <updated>2023-01-06T00:00:00-06:00</updated>
   <content type="html">&lt;h4 id=&quot;시리즈-목차&quot;&gt;시리즈 목차&lt;/h4&gt; &lt;p&gt;&lt;a href=&quot;https://moonqqqq.github.io/join-algorithms-1&quot;&gt;1. Join 알고리즘의 종류&lt;/a&gt; &lt;br /&gt; &lt;u&gt;(현재글) 2. Join 알고리즘 최적화&lt;/u&gt; &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;3가지-조인-비교&quot;&gt;3가지 조인 비교&lt;/h1&gt; &lt;p&gt;3가지 조인 알고리즘이 어떤 상황에 선택되는지(유리한지) 알아보자. 일단은 시간복잡도부터 따져보면. Nested Loop은 O(N*M), Hash와 Sort-Merge는 O(N+M)이다.&lt;/p&gt; &lt;p&gt;조인 알고리즘은 &lt;strong&gt;WHERE문으로 필터링된 데이터의 갯수&lt;/strong&gt;에 따라 첫번째로 갈린다. WHERE문으로 필터링이 많이돼서 Join할...</content>
 </entry>

 

</feed>