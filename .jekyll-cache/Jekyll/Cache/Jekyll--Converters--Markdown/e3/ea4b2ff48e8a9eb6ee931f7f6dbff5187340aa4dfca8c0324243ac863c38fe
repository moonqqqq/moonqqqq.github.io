I";<h4 id="시리즈-목차">시리즈 목차</h4>
<p><u>(현재글) 1. Join 알고리즘의 종류</u> <br />
<a href="https://moonqqqq.github.io/join-algorithms-1">2. Join 알고리즘 최적화</a> <br /></p>

<hr />
<p><br />
Join을 포함한 쿼리가 실행될 때 데이터베이스 프로세서는 지금 디비 상황에 맞는 join 알고리즘을 선택해야 한다. 대표적인 3가지를 알아보자.</p>

<h1 id="nested-loop-join">Nested Loop Join</h1>
<p>이름 그대로 중첩 loop 방식으로 조건에 맞는 데이터를 찾는다. 중첩 for문이라고 생각하면 된다.
첫번째 테이블에서 데이터를 하나 선택하고 두번째 테이블을 선회하면서 둘의 조인키를 확인하며 조건이 맞는지 확인한다.
User와 School 테이블이 있고 서로가 userId로 조인된 상태라면 아래 처럼 작동한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">user</span> <span class="k">of</span> <span class="nx">users</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 첫번째 Loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">school</span> <span class="k">of</span> <span class="nx">schools</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 두번째 Loop</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">schoolId</span> <span class="o">===</span> <span class="nx">school</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 두 테이블의 데이터를 가져왔으니 조인 조건 확인.</span>
            <span class="nx">pushToResultArray</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">school</span><span class="p">)</span> <span class="c1">// 조건이 맞다면 결과에 추가.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>이렇게 하면 복잡도가 n제곱이라서 성능상 좋지않은거냐고 할수 있다. 맞다. 그래서 많은 양의 데이터를 검색할때는 성능이 좋지않다.
그런데 대부분의 쿼리에는 <strong>where절</strong>이 있기때문에 최대한 loop에 돌아가는 범위를 줄이게 된다. where로 데이터 범위를 줄일수 없다면 데이터베이스가 알아서 다른 join 알고리즘으로 변경하여 성능을 최적화한다.</p>

<h1 id="hash-join">Hash Join</h1>
<p>Hash Join은 두 테이블이 조인하는 특정 값을 이용한다. 둘이 같은 값을 가지고 있기 때문에(user, school이라면 user가 schoolId를 가지므로 같은 값을 가짐.) <strong>같은 해시 함수를 실행하면 같은 응답값이 나오는 걸 이용하는 것이다.</strong></p>

<p>먼저 해시 테이블을 만든다. 조인된 두 테이블 중 사이즈가 작은 테이블을 찾는다. 그리고 작은 사이즈의 테이블로 해시테이블을 만든다. <strong>해시 테이블</strong>의 키는 조인에 이용되는 값을 해시 함수 실행시켜 얻은 값이다. <strong>해시 테이블의 값</strong>은 해당 열이다. 해당 열의 일부분이 될수도 있고 전부가 될수도 있다. 혹은 해당 열의 메모리 주소값일수도 있다.(메모리 주소로 값을 저장하면 추후에 메모리 주소로 다시 접근하여 데이터를 얻어야하는 단점이 있다.)</p>

<p>데이터가 아래와 같다면</p>

<p><img src="/img/writing-images/usertable.png" alt="1" />
<img src="/img/writing-images/schooltable.png" alt="2" /></p>

<p>먼저 School테이블이 사이즈가 더 작기때문에 School 테이블을 이용하여 해시 테이블을 만든다. User와 School 테이블은 schoolId로 서로 조인하고 있기 때문에 School.id를 해시함수 실행시켜 키 값을 설정한다. 그리고 해시 테이블의 값으로는 해당 열 데이터의 일부를 저장한다. 예시에서는 school 데이터의 ID를 저장한다.</p>

<p>‘aaa1’은 1을 해시함수 돌린 값, ‘aaa2’는 2를 해시함수 돌린값이라고 생각하자.</p>

<p><img src="/img/writing-images/hashtable.png" alt="2" /></p>

<p><strong>이제 나머지 테이블(크기가 좀더 큰 테이블: User)</strong>에서 작업을 시작한다. User 테이블을 순회하여 School과의 조인을 나타내는 값을 해시 함수 실행시킨다. 해시 함수 실행 결과 값을 해시 테이블과 매칭해서 같은 값이 있으면 해당 테이블과 결합시킨다. 그리고 결과 목록에 추가한다. User 테이블에서 순회를 마치면 결과 목록이 완성된다.</p>

<p>대략 코드로 표현하면 이렇다.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">smallerTable</span> <span class="o">=</span> <span class="nx">findSmallerTable</span><span class="p">(</span><span class="nx">Users</span><span class="p">,</span> <span class="nx">Schools</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">biggerTable</span> <span class="o">=</span> <span class="nx">Users</span> <span class="o">===</span> <span class="nx">smallerTable</span> <span class="p">?</span> <span class="nx">Schools</span> <span class="p">:</span> <span class="nx">Users</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">hashTable</span> <span class="o">=</span> <span class="nx">createHashTable</span><span class="p">(</span><span class="nx">smallerTable</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">eachRow</span> <span class="k">of</span> <span class="nx">biggerTable</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">joinedTable</span> <span class="o">=</span> <span class="nx">findMatchingDataFromOtherTable</span><span class="p">(</span><span class="nx">hashFunc</span><span class="p">(</span><span class="nx">eachRow</span><span class="p">.</span><span class="nx">joinKey</span><span class="p">))</span>

    <span class="k">return</span> <span class="nx">pushToJoinResult</span><span class="p">(</span><span class="nx">joinedTable</span><span class="p">,</span> <span class="nx">eachRwo</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="merge-join">Merge Join</h1>

<p>Merge 조인은 조인되는 두 테이블을 각자 조인키 값을 기준으로 정렬시킨다.</p>

<table>
  <thead>
    <tr>
      <th>USERS</th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
      <th>scholl_Id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>kim</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2</td>
      <td>lee</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>choi</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>lim</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>SCHOOLS</th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>seoul</td>
    </tr>
    <tr>
      <td>2</td>
      <td>busan</td>
    </tr>
    <tr>
      <td>4</td>
      <td>lala</td>
    </tr>
  </tbody>
</table>

<p><br />
위 값으로 Merge 조인을 한다면</p>

<ol>
  <li>개별 테이블이 공유하는 조인키로 정렬된다.</li>
</ol>

<p>아래를 보면 USERS가 school_id로 정렬된 걸 확인할 수 있다.</p>

<table>
  <thead>
    <tr>
      <th>USERS</th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>school_id</th>
      <th>name</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>lee</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>choi</td>
      <td>3</td>
    </tr>
    <tr>
      <td>3</td>
      <td>kim</td>
      <td>1</td>
    </tr>
    <tr>
      <td>6</td>
      <td>lim</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>SCHOLLS</th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>seoul</td>
    </tr>
    <tr>
      <td>2</td>
      <td>busan</td>
    </tr>
    <tr>
      <td>4</td>
      <td>lala</td>
    </tr>
  </tbody>
</table>

<p>(School id로 정렬된 두 테이블)</p>

<ol>
  <li>이제 두 테이블을 맨위 부터 비교하며 조인 키값이 같은 데이터들을 찾는다.</li>
</ol>

<h4 id="첫번째-비교">첫번째 비교</h4>

<table>
  <thead>
    <tr>
      <th>USERS</th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>school_id</th>
      <th>name</th>
      <th>id</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>lee</td>
      <td>2</td>
      <td>O</td>
    </tr>
    <tr>
      <td>2</td>
      <td>choi</td>
      <td>3</td>
      <td> </td>
    </tr>
    <tr>
      <td>3</td>
      <td>kim</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>6</td>
      <td>lim</td>
      <td>4</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>SCHOLLS</th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>seoul</td>
      <td>O</td>
    </tr>
    <tr>
      <td>2</td>
      <td>busan</td>
      <td> </td>
    </tr>
    <tr>
      <td>4</td>
      <td>lala</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>같은 키로 정렬된 상태이므로 바로바로 같은 조인키 값을 가진 데이터들을 찾을수 있다. 
같은 포인터 위치의 데이터끼리 조인키를 비교한다. <strong>값이 같다면 둘의 데이터를 병합하여 결과 데이터에 추가한다.
그리고 두 테이블 모두 포인터를 다음번 데이터로 옮긴다.</strong></p>

<h4 id="두번째-비교">두번째 비교</h4>

<table>
  <thead>
    <tr>
      <th>USERS</th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>school_id</th>
      <th>name</th>
      <th>id</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>lee</td>
      <td>2</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>choi</td>
      <td>3</td>
      <td>O</td>
    </tr>
    <tr>
      <td>3</td>
      <td>kim</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>6</td>
      <td>lim</td>
      <td>4</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>SCHOLLS</th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>seoul</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>busan</td>
      <td>O</td>
    </tr>
    <tr>
      <td>4</td>
      <td>lala</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>두번째 비교에서도 바로 포인터에 있는 데이터들이 조인키가 같다. 결과 목록에 병합하여 추가한다.</p>

<h4 id="세번째-비교">세번째 비교</h4>

<table>
  <thead>
    <tr>
      <th>USERS</th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>school_id</th>
      <th>name</th>
      <th>id</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>lee</td>
      <td>2</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>choi</td>
      <td>3</td>
      <td> </td>
    </tr>
    <tr>
      <td>3</td>
      <td>kim</td>
      <td>1</td>
      <td>O</td>
    </tr>
    <tr>
      <td>6</td>
      <td>lim</td>
      <td>4</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>SCHOLLS</th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>seoul</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>busan</td>
      <td> </td>
    </tr>
    <tr>
      <td>4</td>
      <td>lala</td>
      <td>O</td>
    </tr>
  </tbody>
</table>

<p>세번째에 와서야 포인터에있는 값들이 조인키가 맞지않다. 이럴 때는 조인키를 비교하여 작은 값을 가진쪽에서 포인터를 다음으로 옮긴다.</p>

<h4 id="네번째-비교">네번째 비교</h4>

<table>
  <thead>
    <tr>
      <th>USERS</th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>school_id</th>
      <th>name</th>
      <th>id</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>lee</td>
      <td>2</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>choi</td>
      <td>3</td>
      <td> </td>
    </tr>
    <tr>
      <td>3</td>
      <td>kim</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>6</td>
      <td>lim</td>
      <td>4</td>
      <td>O</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>SCHOLLS</th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>id</th>
      <th>name</th>
      <th>pointer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>seoul</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>busan</td>
      <td> </td>
    </tr>
    <tr>
      <td>4</td>
      <td>lala</td>
      <td>O</td>
    </tr>
  </tbody>
</table>

<p>이번에도 포인터들의 조인값을 비교해봤지만 같지 않다. 그런데 이번에는 조인값이 작은 쪽에서 더이상 다음 값으로 옮길수가 없다. 이러면 더이상 매칭할 데이터가 없는 것이기 때문에 탐색 과정이 끝난다. 그리고 병합된 데이터를 리턴한다.</p>

<p>이때 Join 방식에 따라(inner, left, right, full etc..) 매칭되지않은 데이터들에 대해 null을 한쪽 테이블 데이터는 null을 설정해서 결과값에 추가할지 두 테이블 데이터 모두 보여주지않을지 결정하게 된다.</p>

<p><br /></p>

<hr />
<p>다음 글에서는 이 3가지 알고리즘의 최적화에 대해 알아보자.</p>
:ET